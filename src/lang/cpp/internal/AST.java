/** 
 * Copyright (c) 2016-2018, Rodin Aarssen, Centrum Wiskunde & Informatica (CWI)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// This code was generated by lang::cpp::ASTgen
package lang.cpp.internal;

import io.usethesource.vallang.type.Type;
import io.usethesource.vallang.type.TypeFactory;
import io.usethesource.vallang.type.TypeStore;
import io.usethesource.vallang.*;
import java.util.Map;
import java.util.HashMap;

@SuppressWarnings("deprecation")
public class AST {
  private static TypeStore typestore = new TypeStore();
  private static TypeFactory tf = TypeFactory.getInstance();
  private IValueFactory vf;

  public AST (IValueFactory vf) {
    this.vf = vf;
  }

  private static final Type _Declarator = tf.abstractDataType(typestore, "Declarator");
  private static final Type _DeclSpecifier = tf.abstractDataType(typestore, "DeclSpecifier");
  private static final Type _Declaration = tf.abstractDataType(typestore, "Declaration");
  private static final Type _Expression = tf.abstractDataType(typestore, "Expression");
  private static final Type _Type = tf.abstractDataType(typestore, "Type");
  private static final Type _Statement = tf.abstractDataType(typestore, "Statement");
  private static final Type _Modifier = tf.abstractDataType(typestore, "Modifier");
  private static final Type _TypeSymbol = tf.abstractDataType(typestore, "TypeSymbol");
  private static final Type _Attribute = tf.abstractDataType(typestore, "Attribute");
  private static final Type _TypeModifier = tf.abstractDataType(typestore, "TypeModifier");
  private static final Type _M3 = tf.abstractDataType(typestore, "M3");
  private static final Type _Name = tf.abstractDataType(typestore, "Name");
   
  
  
  private static final Type _Declarator_functionDeclaratorNested_6 
    = tf.constructor(typestore,_Declarator,"functionDeclaratorNested",tf.listType(_Declaration),"pointerOperators",tf.listType(_Modifier),"modifiers",_Declarator,"declarator",tf.listType(_Declaration),"parameters",tf.listType(_Declaration),"virtSpecifiers",_Expression,"initializer");
  private static final Type _Declarator_functionDeclarator_3 
    = tf.constructor(typestore,_Declarator,"functionDeclarator",tf.listType(_Declaration),"pointerOperators",_Name,"name",tf.listType(_Declaration),"parameters");
  private static final Type _Declarator_functionDeclaratorWithES_5 
    = tf.constructor(typestore,_Declarator,"functionDeclaratorWithES",tf.listType(_Declaration),"pointerOperators",tf.listType(_Modifier),"modifiers",_Name,"name",tf.listType(_Declaration),"parameters",tf.listType(_Declaration),"virtSpecifiers");
  private static final Type _Declarator_functionDeclaratorNoexcept_6 
    = tf.constructor(typestore,_Declarator,"functionDeclaratorNoexcept",tf.listType(_Declaration),"pointerOperators",tf.listType(_Modifier),"modifiers",_Name,"name",tf.listType(_Declaration),"parameters",tf.listType(_Declaration),"virtSpecifiers",_Expression,"noexceptExpression");
  private static final Type _Declarator_arrayDeclaratorNested_3 
    = tf.constructor(typestore,_Declarator,"arrayDeclaratorNested",tf.listType(_Declaration),"pointerOperators",_Declarator,"declarator",tf.listType(_Expression),"arrayModifier");
  private static final Type _Declarator_functionDeclarator_6 
    = tf.constructor(typestore,_Declarator,"functionDeclarator",tf.listType(_Declaration),"pointerOperators",tf.listType(_Modifier),"modifiers",_Name,"name",tf.listType(_Declaration),"parameters",tf.listType(_Declaration),"virtSpecifiers",_Expression,"trailingReturnType");
  private static final Type _Declarator_declarator_3 
    = tf.constructor(typestore,_Declarator,"declarator",tf.listType(_Declaration),"pointerOperators",_Name,"name",_Expression,"initializer");
  private static final Type _Declarator_arrayDeclarator_4 
    = tf.constructor(typestore,_Declarator,"arrayDeclarator",tf.listType(_Declaration),"pointerOperators",_Name,"name",tf.listType(_Expression),"arrayModifier",_Expression,"initializer");
  private static final Type _Declarator_declarator_2 
    = tf.constructor(typestore,_Declarator,"declarator",tf.listType(_Declaration),"pointerOperators",_Name,"name");
  private static final Type _Declarator_missingDeclarator_0 
    = tf.constructor(typestore,_Declarator,"missingDeclarator");
  private static final Type _Declarator_functionDeclaratorWithES_6 
    = tf.constructor(typestore,_Declarator,"functionDeclaratorWithES",tf.listType(_Declaration),"pointerOperators",tf.listType(_Modifier),"modifiers",_Name,"name",tf.listType(_Declaration),"parameters",tf.listType(_Declaration),"virtSpecifiers",tf.listType(_Expression),"exceptionSpecification");
  private static final Type _Declarator_fieldDeclarator_3 
    = tf.constructor(typestore,_Declarator,"fieldDeclarator",tf.listType(_Declaration),"pointerOperators",_Name,"name",_Expression,"bitFieldSize");
  private static final Type _Declarator_arrayDeclarator_3 
    = tf.constructor(typestore,_Declarator,"arrayDeclarator",tf.listType(_Declaration),"pointerOperators",_Name,"name",tf.listType(_Expression),"arrayModifier");
  private static final Type _Declarator_functionDeclarator_5 
    = tf.constructor(typestore,_Declarator,"functionDeclarator",tf.listType(_Declaration),"pointerOperators",tf.listType(_Modifier),"modifiers",_Name,"name",tf.listType(_Declaration),"parameters",tf.listType(_Declaration),"virtSpecifiers");
  private static final Type _Declarator_fieldDeclarator_4 
    = tf.constructor(typestore,_Declarator,"fieldDeclarator",tf.listType(_Declaration),"pointerOperators",_Name,"name",_Expression,"bitFieldSize",_Expression,"initializer");
  private static final Type _Declarator_functionDeclaratorNested_5 
    = tf.constructor(typestore,_Declarator,"functionDeclaratorNested",tf.listType(_Declaration),"pointerOperators",tf.listType(_Modifier),"modifiers",_Declarator,"declarator",tf.listType(_Declaration),"parameters",tf.listType(_Declaration),"virtSpecifiers");
  private static final Type _Declarator_arrayDeclaratorNested_4 
    = tf.constructor(typestore,_Declarator,"arrayDeclaratorNested",tf.listType(_Declaration),"pointerOperators",_Declarator,"declarator",tf.listType(_Expression),"arrayModifier",_Expression,"initializer");
  
  
  private static final Type _DeclSpecifier_enum_4 
    = tf.constructor(typestore,_DeclSpecifier,"enum",tf.listType(_Modifier),"modifiers",_DeclSpecifier,"baseType",_Name,"name",tf.listType(_Declaration),"enumerators");
  private static final Type _DeclSpecifier_etsEnum_2 
    = tf.constructor(typestore,_DeclSpecifier,"etsEnum",tf.listType(_Modifier),"modifiers",_Name,"name");
  private static final Type _DeclSpecifier_struct_4 
    = tf.constructor(typestore,_DeclSpecifier,"struct",tf.listType(_Modifier),"modifiers",_Name,"name",tf.listType(_Declaration),"baseSpecifiers",tf.listType(_Declaration),"members");
  private static final Type _DeclSpecifier_class_3 
    = tf.constructor(typestore,_DeclSpecifier,"class",tf.listType(_Modifier),"modifiers",_Name,"name",tf.listType(_Declaration),"members");
  private static final Type _DeclSpecifier_classFinal_4 
    = tf.constructor(typestore,_DeclSpecifier,"classFinal",tf.listType(_Modifier),"modifiers",_Name,"name",tf.listType(_Declaration),"baseSpecifiers",tf.listType(_Declaration),"members");
  private static final Type _DeclSpecifier_struct_3 
    = tf.constructor(typestore,_DeclSpecifier,"struct",tf.listType(_Modifier),"modifiers",_Name,"name",tf.listType(_Declaration),"members");
  private static final Type _DeclSpecifier_union_3 
    = tf.constructor(typestore,_DeclSpecifier,"union",tf.listType(_Modifier),"modifiers",_Name,"name",tf.listType(_Declaration),"members");
  private static final Type _DeclSpecifier_declSpecifier_2 
    = tf.constructor(typestore,_DeclSpecifier,"declSpecifier",tf.listType(_Modifier),"modifiers",_Type,"type");
  private static final Type _DeclSpecifier_union_4 
    = tf.constructor(typestore,_DeclSpecifier,"union",tf.listType(_Modifier),"modifiers",_Name,"name",tf.listType(_Declaration),"baseSpecifiers",tf.listType(_Declaration),"members");
  private static final Type _DeclSpecifier_etsStruct_2 
    = tf.constructor(typestore,_DeclSpecifier,"etsStruct",tf.listType(_Modifier),"modifiers",_Name,"name");
  private static final Type _DeclSpecifier_declSpecifier_3 
    = tf.constructor(typestore,_DeclSpecifier,"declSpecifier",tf.listType(_Modifier),"modifiers",_Type,"type",_Expression,"expression");
  private static final Type _DeclSpecifier_msThrowEllipsis_0 
    = tf.constructor(typestore,_DeclSpecifier,"msThrowEllipsis");
  private static final Type _DeclSpecifier_enumScoped_3 
    = tf.constructor(typestore,_DeclSpecifier,"enumScoped",tf.listType(_Modifier),"modifiers",_Name,"name",tf.listType(_Declaration),"enumerators");
  private static final Type _DeclSpecifier_enumOpaque_3 
    = tf.constructor(typestore,_DeclSpecifier,"enumOpaque",tf.listType(_Modifier),"modifiers",_DeclSpecifier,"baseType",_Name,"name");
  private static final Type _DeclSpecifier_namedTypeSpecifier_2 
    = tf.constructor(typestore,_DeclSpecifier,"namedTypeSpecifier",tf.listType(_Modifier),"modifiers",_Name,"name");
  private static final Type _DeclSpecifier_class_4 
    = tf.constructor(typestore,_DeclSpecifier,"class",tf.listType(_Modifier),"modifiers",_Name,"name",tf.listType(_Declaration),"baseSpecifiers",tf.listType(_Declaration),"members");
  private static final Type _DeclSpecifier_etsUnion_2 
    = tf.constructor(typestore,_DeclSpecifier,"etsUnion",tf.listType(_Modifier),"modifiers",_Name,"name");
  private static final Type _DeclSpecifier_unionFinal_4 
    = tf.constructor(typestore,_DeclSpecifier,"unionFinal",tf.listType(_Modifier),"modifiers",_Name,"name",tf.listType(_Declaration),"baseSpecifiers",tf.listType(_Declaration),"members");
  private static final Type _DeclSpecifier_enumScoped_4 
    = tf.constructor(typestore,_DeclSpecifier,"enumScoped",tf.listType(_Modifier),"modifiers",_DeclSpecifier,"baseType",_Name,"name",tf.listType(_Declaration),"enumerators");
  private static final Type _DeclSpecifier_etsClass_2 
    = tf.constructor(typestore,_DeclSpecifier,"etsClass",tf.listType(_Modifier),"modifiers",_Name,"name");
  private static final Type _DeclSpecifier_enumScopedOpaque_2 
    = tf.constructor(typestore,_DeclSpecifier,"enumScopedOpaque",tf.listType(_Modifier),"modifiers",_Name,"name");
  private static final Type _DeclSpecifier_structFinal_4 
    = tf.constructor(typestore,_DeclSpecifier,"structFinal",tf.listType(_Modifier),"modifiers",_Name,"name",tf.listType(_Declaration),"baseSpecifiers",tf.listType(_Declaration),"members");
  private static final Type _DeclSpecifier_enum_3 
    = tf.constructor(typestore,_DeclSpecifier,"enum",tf.listType(_Modifier),"modifiers",_Name,"name",tf.listType(_Declaration),"enumerators");
  private static final Type _DeclSpecifier_enumScopedOpaque_3 
    = tf.constructor(typestore,_DeclSpecifier,"enumScopedOpaque",tf.listType(_Modifier),"modifiers",_DeclSpecifier,"baseType",_Name,"name");
  
  
  private static final Type _Declaration_sttClass_1 
    = tf.constructor(typestore,_Declaration,"sttClass",_Name,"name");
  private static final Type _Declaration_namespaceDefinitionInline_2 
    = tf.constructor(typestore,_Declaration,"namespaceDefinitionInline",_Name,"name",tf.listType(_Declaration),"declarations");
  private static final Type _Declaration_asmDeclaration_1 
    = tf.constructor(typestore,_Declaration,"asmDeclaration",tf.stringType(),"assembly");
  private static final Type _Declaration_reference_0 
    = tf.constructor(typestore,_Declaration,"reference");
  private static final Type _Declaration_template_3 
    = tf.constructor(typestore,_Declaration,"template",tf.listType(_Declaration),"parameters",_Declaration,"declaration",_TypeSymbol,"type");
  private static final Type _Declaration_explicitTemplateInstantiation_2 
    = tf.constructor(typestore,_Declaration,"explicitTemplateInstantiation",_Modifier,"modifier",_Declaration,"declaration");
  private static final Type _Declaration_functionDefinition_4 
    = tf.constructor(typestore,_Declaration,"functionDefinition",_DeclSpecifier,"declSpecifier",_Declarator,"declarator",tf.listType(_Expression),"memberInitializer",_Statement,"body");
  private static final Type _Declaration_pointerToMember_2 
    = tf.constructor(typestore,_Declaration,"pointerToMember",tf.listType(_Modifier),"modifiers",_Name,"nestedName");
  private static final Type _Declaration_translationUnit_1 
    = tf.constructor(typestore,_Declaration,"translationUnit",tf.listType(_Declaration),"declarations");
  private static final Type _Declaration_parameter_2 
    = tf.constructor(typestore,_Declaration,"parameter",_DeclSpecifier,"declSpecifier",_Declarator,"declarator");
  private static final Type _Declaration_enumerator_2 
    = tf.constructor(typestore,_Declaration,"enumerator",_Name,"name",_Expression,"value");
  private static final Type _Declaration_varArgs_0 
    = tf.constructor(typestore,_Declaration,"varArgs");
  private static final Type _Declaration_simpleDeclaration_2 
    = tf.constructor(typestore,_Declaration,"simpleDeclaration",_DeclSpecifier,"declSpecifier",tf.listType(_Declarator),"declarators");
  private static final Type _Declaration_sttClass_2 
    = tf.constructor(typestore,_Declaration,"sttClass",_Name,"name",_Expression,"defaultType");
  private static final Type _Declaration_linkageSpecification_2 
    = tf.constructor(typestore,_Declaration,"linkageSpecification",tf.stringType(),"literal",tf.listType(_Declaration),"declarations");
  private static final Type _Declaration_namespaceDefinition_2 
    = tf.constructor(typestore,_Declaration,"namespaceDefinition",_Name,"name",tf.listType(_Declaration),"declarations");
  private static final Type _Declaration_baseSpecifier_2 
    = tf.constructor(typestore,_Declaration,"baseSpecifier",tf.listType(_Modifier),"modifiers",_Name,"name");
  private static final Type _Declaration_explicitTemplateInstantiation_1 
    = tf.constructor(typestore,_Declaration,"explicitTemplateInstantiation",_Declaration,"declaration");
  private static final Type _Declaration_explicitTemplateSpecialization_1 
    = tf.constructor(typestore,_Declaration,"explicitTemplateSpecialization",_Declaration,"declaration");
  private static final Type _Declaration_tttParameter_2 
    = tf.constructor(typestore,_Declaration,"tttParameter",tf.listType(_Declaration),"nestedParameters",_Name,"name");
  private static final Type _Declaration_rvalueReference_0 
    = tf.constructor(typestore,_Declaration,"rvalueReference");
  private static final Type _Declaration_enumerator_1 
    = tf.constructor(typestore,_Declaration,"enumerator",_Name,"name");
  private static final Type _Declaration_namespaceAlias_2 
    = tf.constructor(typestore,_Declaration,"namespaceAlias",_Name,"alias",_Name,"mapping");
  private static final Type _Declaration_staticAssert_2 
    = tf.constructor(typestore,_Declaration,"staticAssert",_Expression,"condition",_Expression,"message");
  private static final Type _Declaration_alias_2 
    = tf.constructor(typestore,_Declaration,"alias",_Name,"alias",_Expression,"mappingTypeId");
  private static final Type _Declaration_visibilityLabel_1 
    = tf.constructor(typestore,_Declaration,"visibilityLabel",_Modifier,"visibility");
  private static final Type _Declaration_functionWithTryBlockDefinition_5 
    = tf.constructor(typestore,_Declaration,"functionWithTryBlockDefinition",_DeclSpecifier,"declSpecifier",_Declarator,"declarator",tf.listType(_Expression),"memberInitializers",_Statement,"sbody",tf.listType(_Statement),"catchHandlers");
  private static final Type _Declaration_parameter_1 
    = tf.constructor(typestore,_Declaration,"parameter",_DeclSpecifier,"declSpecifier");
  private static final Type _Declaration_sttTypename_1 
    = tf.constructor(typestore,_Declaration,"sttTypename",_Name,"name");
  private static final Type _Declaration_virtSpecifier_1 
    = tf.constructor(typestore,_Declaration,"virtSpecifier",_Modifier,"modifier");
  private static final Type _Declaration_defaultedFunctionDefinition_3 
    = tf.constructor(typestore,_Declaration,"defaultedFunctionDefinition",_DeclSpecifier,"declSpecifier",tf.listType(_Expression),"memberInitializer",_Declarator,"declarator");
  private static final Type _Declaration_usingDeclaration_2 
    = tf.constructor(typestore,_Declaration,"usingDeclaration",tf.listType(_Modifier),"modifiers",_Name,"name");
  private static final Type _Declaration_pointer_1 
    = tf.constructor(typestore,_Declaration,"pointer",tf.listType(_Modifier),"modifiers");
  private static final Type _Declaration_usingDirective_1 
    = tf.constructor(typestore,_Declaration,"usingDirective",_Name,"qualifiedName");
  private static final Type _Declaration_deletedFunctionDefinition_3 
    = tf.constructor(typestore,_Declaration,"deletedFunctionDefinition",_DeclSpecifier,"declSpecifier",tf.listType(_Expression),"memberInitializer",_Declarator,"declarator");
  private static final Type _Declaration_functionDefinition_3 
    = tf.constructor(typestore,_Declaration,"functionDefinition",_Expression,"returnSpec",_Declarator,"declarator",_Statement,"body");
  private static final Type _Declaration_baseSpecifier_1 
    = tf.constructor(typestore,_Declaration,"baseSpecifier",tf.listType(_Modifier),"modifiers");
  private static final Type _Declaration_problemDeclaration_0 
    = tf.constructor(typestore,_Declaration,"problemDeclaration");
  private static final Type _Declaration_sttTypename_2 
    = tf.constructor(typestore,_Declaration,"sttTypename",_Name,"name",_Expression,"defaultType");
  
  
  private static final Type _Expression_cast_2 
    = tf.constructor(typestore,_Expression,"cast",_Expression,"typeId",_Expression,"expression");
  private static final Type _Expression_empty_0 
    = tf.constructor(typestore,_Expression,"empty");
  private static final Type _Expression_postfixIncr_1 
    = tf.constructor(typestore,_Expression,"postfixIncr",_Expression,"expression");
  private static final Type _Expression_newWithArgs_3 
    = tf.constructor(typestore,_Expression,"newWithArgs",tf.listType(_Expression),"arguments",_Expression,"typeId",_Expression,"initializer");
  private static final Type _Expression_sizeofParameterPack_1 
    = tf.constructor(typestore,_Expression,"sizeofParameterPack",_Expression,"expression");
  private static final Type _Expression_assign_2 
    = tf.constructor(typestore,_Expression,"assign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_modulo_2 
    = tf.constructor(typestore,_Expression,"modulo",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_binaryAnd_2 
    = tf.constructor(typestore,_Expression,"binaryAnd",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_throw_0 
    = tf.constructor(typestore,_Expression,"throw");
  private static final Type _Expression_nullptr_0 
    = tf.constructor(typestore,_Expression,"nullptr");
  private static final Type _Expression_alignOf_1 
    = tf.constructor(typestore,_Expression,"alignOf",_Expression,"expression");
  private static final Type _Expression_initializerList_1 
    = tf.constructor(typestore,_Expression,"initializerList",tf.listType(_Expression),"clauses");
  private static final Type _Expression_globalNew_2 
    = tf.constructor(typestore,_Expression,"globalNew",_Expression,"typeId",_Expression,"initializer");
  private static final Type _Expression_simpleTypeConstructor_2 
    = tf.constructor(typestore,_Expression,"simpleTypeConstructor",_DeclSpecifier,"declSpecifier",_Expression,"initializer");
  private static final Type _Expression_dynamicCast_2 
    = tf.constructor(typestore,_Expression,"dynamicCast",_Expression,"typeId",_Expression,"expression");
  private static final Type _Expression_ellipses_2 
    = tf.constructor(typestore,_Expression,"ellipses",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_constructorInitializer_1 
    = tf.constructor(typestore,_Expression,"constructorInitializer",tf.listType(_Expression),"arguments");
  private static final Type _Expression_reinterpretCast_2 
    = tf.constructor(typestore,_Expression,"reinterpretCast",_Expression,"typeId",_Expression,"expression");
  private static final Type _Expression_min_2 
    = tf.constructor(typestore,_Expression,"min",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_arrayRangeDesignator_2 
    = tf.constructor(typestore,_Expression,"arrayRangeDesignator",_Expression,"rangeFloor",_Expression,"rangeCeiling");
  private static final Type _Expression_notEquals_2 
    = tf.constructor(typestore,_Expression,"notEquals",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_tilde_1 
    = tf.constructor(typestore,_Expression,"tilde",_Expression,"expression");
  private static final Type _Expression_binaryOrAssign_2 
    = tf.constructor(typestore,_Expression,"binaryOrAssign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_arrayModifier_1 
    = tf.constructor(typestore,_Expression,"arrayModifier",_Expression,"constExpression");
  private static final Type _Expression_false_0 
    = tf.constructor(typestore,_Expression,"false");
  private static final Type _Expression_sizeof_1 
    = tf.constructor(typestore,_Expression,"sizeof",_Expression,"expression");
  private static final Type _Expression_multiplyAssign_2 
    = tf.constructor(typestore,_Expression,"multiplyAssign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_nyi_1 
    = tf.constructor(typestore,_Expression,"nyi",tf.stringType(),"raw");
  private static final Type _Expression_minus_2 
    = tf.constructor(typestore,_Expression,"minus",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_new_1 
    = tf.constructor(typestore,_Expression,"new",_Expression,"typeId");
  private static final Type _Expression_noexcept_1 
    = tf.constructor(typestore,_Expression,"noexcept",_Expression,"expression");
  private static final Type _Expression_constructorChainInitializer_2 
    = tf.constructor(typestore,_Expression,"constructorChainInitializer",_Name,"name",_Expression,"initializer");
  private static final Type _Expression_plus_1 
    = tf.constructor(typestore,_Expression,"plus",_Expression,"expression");
  private static final Type _Expression_true_0 
    = tf.constructor(typestore,_Expression,"true");
  private static final Type _Expression_typeid_1 
    = tf.constructor(typestore,_Expression,"typeid",_Expression,"expression");
  private static final Type _Expression_charConstant_1 
    = tf.constructor(typestore,_Expression,"charConstant",tf.stringType(),"value");
  private static final Type _Expression_equals_2 
    = tf.constructor(typestore,_Expression,"equals",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_minusAssign_2 
    = tf.constructor(typestore,_Expression,"minusAssign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_typeId_1 
    = tf.constructor(typestore,_Expression,"typeId",_DeclSpecifier,"declSpecifier");
  private static final Type _Expression_labelReference_1 
    = tf.constructor(typestore,_Expression,"labelReference",_Expression,"expression");
  private static final Type _Expression_shiftRight_2 
    = tf.constructor(typestore,_Expression,"shiftRight",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_captureThisPtr_0 
    = tf.constructor(typestore,_Expression,"captureThisPtr");
  private static final Type _Expression_stringLiteral_1 
    = tf.constructor(typestore,_Expression,"stringLiteral",tf.stringType(),"value");
  private static final Type _Expression_amper_1 
    = tf.constructor(typestore,_Expression,"amper",_Expression,"expression");
  private static final Type _Expression_plus_2 
    = tf.constructor(typestore,_Expression,"plus",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_binaryXor_2 
    = tf.constructor(typestore,_Expression,"binaryXor",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_greaterEqual_2 
    = tf.constructor(typestore,_Expression,"greaterEqual",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_fieldReferencePointerDeref_2 
    = tf.constructor(typestore,_Expression,"fieldReferencePointerDeref",_Expression,"fieldOwner",_Name,"name");
  private static final Type _Expression_arraySubscriptExpression_2 
    = tf.constructor(typestore,_Expression,"arraySubscriptExpression",_Expression,"array",_Expression,"argument");
  private static final Type _Expression_lessThan_2 
    = tf.constructor(typestore,_Expression,"lessThan",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_functionCall_2 
    = tf.constructor(typestore,_Expression,"functionCall",_Expression,"functionName",tf.listType(_Expression),"arguments");
  private static final Type _Expression_globalVectoredDelete_1 
    = tf.constructor(typestore,_Expression,"globalVectoredDelete",_Expression,"expression");
  private static final Type _Expression_lessEqual_2 
    = tf.constructor(typestore,_Expression,"lessEqual",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_minus_1 
    = tf.constructor(typestore,_Expression,"minus",_Expression,"expression");
  private static final Type _Expression_greaterThan_2 
    = tf.constructor(typestore,_Expression,"greaterThan",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_capture_1 
    = tf.constructor(typestore,_Expression,"capture",_Name,"name");
  private static final Type _Expression_not_1 
    = tf.constructor(typestore,_Expression,"not",_Expression,"expression");
  private static final Type _Expression_shiftLeftAssign_2 
    = tf.constructor(typestore,_Expression,"shiftLeftAssign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_typeId_2 
    = tf.constructor(typestore,_Expression,"typeId",_DeclSpecifier,"declSpecifier",_Declarator,"abstractDeclarator");
  private static final Type _Expression_star_1 
    = tf.constructor(typestore,_Expression,"star",_Expression,"expression");
  private static final Type _Expression_divide_2 
    = tf.constructor(typestore,_Expression,"divide",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_staticCast_2 
    = tf.constructor(typestore,_Expression,"staticCast",_Expression,"typeId",_Expression,"expression");
  private static final Type _Expression_integerConstant_1 
    = tf.constructor(typestore,_Expression,"integerConstant",tf.stringType(),"value");
  private static final Type _Expression_vectoredDelete_1 
    = tf.constructor(typestore,_Expression,"vectoredDelete",_Expression,"expression");
  private static final Type _Expression_problemExpression_0 
    = tf.constructor(typestore,_Expression,"problemExpression");
  private static final Type _Expression_newWithArgs_2 
    = tf.constructor(typestore,_Expression,"newWithArgs",tf.listType(_Expression),"arguments",_Expression,"typeId");
  private static final Type _Expression_designatedInitializer_2 
    = tf.constructor(typestore,_Expression,"designatedInitializer",tf.listType(_Expression),"designators",_Expression,"operand");
  private static final Type _Expression_floatConstant_1 
    = tf.constructor(typestore,_Expression,"floatConstant",tf.stringType(),"value");
  private static final Type _Expression_multiply_2 
    = tf.constructor(typestore,_Expression,"multiply",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_binaryOr_2 
    = tf.constructor(typestore,_Expression,"binaryOr",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_max_2 
    = tf.constructor(typestore,_Expression,"max",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_fieldDesignator_1 
    = tf.constructor(typestore,_Expression,"fieldDesignator",_Expression,"fieldName");
  private static final Type _Expression_globalNewWithArgs_2 
    = tf.constructor(typestore,_Expression,"globalNewWithArgs",tf.listType(_Expression),"arguments",_Expression,"typeId");
  private static final Type _Expression_globalDelete_1 
    = tf.constructor(typestore,_Expression,"globalDelete",_Expression,"expression");
  private static final Type _Expression_moduloAssign_2 
    = tf.constructor(typestore,_Expression,"moduloAssign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_binaryAndAssign_2 
    = tf.constructor(typestore,_Expression,"binaryAndAssign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_conditional_3 
    = tf.constructor(typestore,_Expression,"conditional",_Expression,"condition",_Expression,"positive",_Expression,"negative");
  private static final Type _Expression_packExpansion_1 
    = tf.constructor(typestore,_Expression,"packExpansion",_Expression,"pattern");
  private static final Type _Expression_expressionList_1 
    = tf.constructor(typestore,_Expression,"expressionList",tf.listType(_Expression),"expressions");
  private static final Type _Expression_globalNewWithArgs_3 
    = tf.constructor(typestore,_Expression,"globalNewWithArgs",tf.listType(_Expression),"arguments",_Expression,"typeId",_Expression,"initializer");
  private static final Type _Expression_delete_1 
    = tf.constructor(typestore,_Expression,"delete",_Expression,"expression");
  private static final Type _Expression_postfixDecr_1 
    = tf.constructor(typestore,_Expression,"postfixDecr",_Expression,"expression");
  private static final Type _Expression_this_0 
    = tf.constructor(typestore,_Expression,"this");
  private static final Type _Expression_logicalAnd_2 
    = tf.constructor(typestore,_Expression,"logicalAnd",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_arrayModifier_0 
    = tf.constructor(typestore,_Expression,"arrayModifier");
  private static final Type _Expression_bracketed_1 
    = tf.constructor(typestore,_Expression,"bracketed",_Expression,"expression");
  private static final Type _Expression_logicalOr_2 
    = tf.constructor(typestore,_Expression,"logicalOr",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_pmDot_2 
    = tf.constructor(typestore,_Expression,"pmDot",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_pmArrow_2 
    = tf.constructor(typestore,_Expression,"pmArrow",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_globalNew_1 
    = tf.constructor(typestore,_Expression,"globalNew",_Expression,"typeId");
  private static final Type _Expression_prefixIncr_1 
    = tf.constructor(typestore,_Expression,"prefixIncr",_Expression,"expression");
  private static final Type _Expression_fieldReference_2 
    = tf.constructor(typestore,_Expression,"fieldReference",_Expression,"fieldOwner",_Name,"name");
  private static final Type _Expression_throw_1 
    = tf.constructor(typestore,_Expression,"throw",_Expression,"expression");
  private static final Type _Expression_idExpression_1 
    = tf.constructor(typestore,_Expression,"idExpression",_Name,"name");
  private static final Type _Expression_typeIdInitializerExpression_2 
    = tf.constructor(typestore,_Expression,"typeIdInitializerExpression",_Expression,"typeId",_Expression,"initializer");
  private static final Type _Expression_arrayDesignator_1 
    = tf.constructor(typestore,_Expression,"arrayDesignator",_Expression,"subscript");
  private static final Type _Expression_compoundStatementExpression_1 
    = tf.constructor(typestore,_Expression,"compoundStatementExpression",_Statement,"compoundStatement");
  private static final Type _Expression_equalsInitializer_1 
    = tf.constructor(typestore,_Expression,"equalsInitializer",_Expression,"initializer");
  private static final Type _Expression_integerLiteral_1 
    = tf.constructor(typestore,_Expression,"integerLiteral",tf.integerType(),"number");
  private static final Type _Expression_divideAssign_2 
    = tf.constructor(typestore,_Expression,"divideAssign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_captureByRef_1 
    = tf.constructor(typestore,_Expression,"captureByRef",_Name,"name");
  private static final Type _Expression_new_2 
    = tf.constructor(typestore,_Expression,"new",_Expression,"typeId",_Expression,"initializer");
  private static final Type _Expression_lambda_4 
    = tf.constructor(typestore,_Expression,"lambda",_Modifier,"captureDefault",tf.listType(_Expression),"captures",_Declarator,"declarator",_Statement,"body");
  private static final Type _Expression_shiftLeft_2 
    = tf.constructor(typestore,_Expression,"shiftLeft",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_plusAssign_2 
    = tf.constructor(typestore,_Expression,"plusAssign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_prefixDecr_1 
    = tf.constructor(typestore,_Expression,"prefixDecr",_Expression,"expression");
  private static final Type _Expression_binaryXorAssign_2 
    = tf.constructor(typestore,_Expression,"binaryXorAssign",_Expression,"lhs",_Expression,"rhs");
  private static final Type _Expression_constCast_2 
    = tf.constructor(typestore,_Expression,"constCast",_Expression,"typeId",_Expression,"expression");
  private static final Type _Expression_shiftRightAssign_2 
    = tf.constructor(typestore,_Expression,"shiftRightAssign",_Expression,"lhs",_Expression,"rhs");
  
  
  private static final Type _Type_wchar_t_0 
    = tf.constructor(typestore,_Type,"wchar_t");
  private static final Type _Type_decltype_0 
    = tf.constructor(typestore,_Type,"decltype");
  private static final Type _Type_decimal128_0 
    = tf.constructor(typestore,_Type,"decimal128");
  private static final Type _Type_nullptr_0 
    = tf.constructor(typestore,_Type,"nullptr");
  private static final Type _Type_int128_0 
    = tf.constructor(typestore,_Type,"int128");
  private static final Type _Type_classType_1 
    = tf.constructor(typestore,_Type,"classType",_Name,"name");
  private static final Type _Type_unionType_1 
    = tf.constructor(typestore,_Type,"unionType",_Name,"name");
  private static final Type _Type_basicType_2 
    = tf.constructor(typestore,_Type,"basicType",_Type,"type",tf.listType(_Modifier),"modifiers");
  private static final Type _Type_char_0 
    = tf.constructor(typestore,_Type,"char");
  private static final Type _Type_unspecified_0 
    = tf.constructor(typestore,_Type,"unspecified");
  private static final Type _Type_arrayType_2 
    = tf.constructor(typestore,_Type,"arrayType",_Type,"type",tf.integerType(),"size");
  private static final Type _Type_float128_0 
    = tf.constructor(typestore,_Type,"float128");
  private static final Type _Type_float_0 
    = tf.constructor(typestore,_Type,"float");
  private static final Type _Type_integer_0 
    = tf.constructor(typestore,_Type,"integer");
  private static final Type _Type_char32_t_0 
    = tf.constructor(typestore,_Type,"char32_t");
  private static final Type _Type_bool_0 
    = tf.constructor(typestore,_Type,"bool");
  private static final Type _Type_decimal64_0 
    = tf.constructor(typestore,_Type,"decimal64");
  private static final Type _Type_auto_0 
    = tf.constructor(typestore,_Type,"auto");
  private static final Type _Type_decimal32_0 
    = tf.constructor(typestore,_Type,"decimal32");
  private static final Type _Type_char16_t_0 
    = tf.constructor(typestore,_Type,"char16_t");
  private static final Type _Type_typeof_0 
    = tf.constructor(typestore,_Type,"typeof");
  private static final Type _Type_double_0 
    = tf.constructor(typestore,_Type,"double");
  private static final Type _Type_void_0 
    = tf.constructor(typestore,_Type,"void");
  private static final Type _Type_structType_1 
    = tf.constructor(typestore,_Type,"structType",_Name,"name");
  
  
  private static final Type _Statement_for_4 
    = tf.constructor(typestore,_Statement,"for",_Statement,"sInitializer",_Expression,"condition",_Expression,"iteration",_Statement,"body");
  private static final Type _Statement_expressionStatement_1 
    = tf.constructor(typestore,_Statement,"expressionStatement",_Expression,"expression");
  private static final Type _Statement_forWithDecl_4 
    = tf.constructor(typestore,_Statement,"forWithDecl",_Statement,"sInitializer",_Declaration,"conditionDeclaration",_Expression,"iteration",_Statement,"body");
  private static final Type _Statement_nullStatement_0 
    = tf.constructor(typestore,_Statement,"nullStatement");
  private static final Type _Statement_ifWithDecl_2 
    = tf.constructor(typestore,_Statement,"ifWithDecl",_Declaration,"conditionDeclaration",_Statement,"thenClause");
  private static final Type _Statement_return_0 
    = tf.constructor(typestore,_Statement,"return");
  private static final Type _Statement_defaultCase_0 
    = tf.constructor(typestore,_Statement,"defaultCase");
  private static final Type _Statement_label_2 
    = tf.constructor(typestore,_Statement,"label",_Name,"name",_Statement,"nestedStatement");
  private static final Type _Statement_continue_0 
    = tf.constructor(typestore,_Statement,"continue");
  private static final Type _Statement_problem_1 
    = tf.constructor(typestore,_Statement,"problem",tf.stringType(),"raw");
  private static final Type _Statement_catch_2 
    = tf.constructor(typestore,_Statement,"catch",_Declaration,"declaration",_Statement,"body");
  private static final Type _Statement_catchAll_1 
    = tf.constructor(typestore,_Statement,"catchAll",_Statement,"body");
  private static final Type _Statement_declarationStatement_1 
    = tf.constructor(typestore,_Statement,"declarationStatement",_Declaration,"declaration");
  private static final Type _Statement_switchWithDecl_2 
    = tf.constructor(typestore,_Statement,"switchWithDecl",_Declaration,"controllerDeclaration",_Statement,"body");
  private static final Type _Statement_compoundStatement_1 
    = tf.constructor(typestore,_Statement,"compoundStatement",tf.listType(_Statement),"statements");
  private static final Type _Statement_case_1 
    = tf.constructor(typestore,_Statement,"case",_Expression,"expression");
  private static final Type _Statement_rangeBasedFor_3 
    = tf.constructor(typestore,_Statement,"rangeBasedFor",_Declaration,"declaration",_Expression,"initializer",_Statement,"body");
  private static final Type _Statement_goto_1 
    = tf.constructor(typestore,_Statement,"goto",_Name,"name");
  private static final Type _Statement_return_1 
    = tf.constructor(typestore,_Statement,"return",_Expression,"expression");
  private static final Type _Statement_while_2 
    = tf.constructor(typestore,_Statement,"while",_Expression,"condition",_Statement,"body");
  private static final Type _Statement_if_3 
    = tf.constructor(typestore,_Statement,"if",_Expression,"condition",_Statement,"thenClause",_Statement,"elseClause");
  private static final Type _Statement_break_0 
    = tf.constructor(typestore,_Statement,"break");
  private static final Type _Statement_ifWithDecl_3 
    = tf.constructor(typestore,_Statement,"ifWithDecl",_Declaration,"conditionDeclaration",_Statement,"thenClause",_Statement,"elseClause");
  private static final Type _Statement_switch_2 
    = tf.constructor(typestore,_Statement,"switch",_Expression,"controller",_Statement,"body");
  private static final Type _Statement_whileWithDecl_2 
    = tf.constructor(typestore,_Statement,"whileWithDecl",_Declaration,"conditionDeclaration",_Statement,"body");
  private static final Type _Statement_if_2 
    = tf.constructor(typestore,_Statement,"if",_Expression,"condition",_Statement,"thenClause");
  private static final Type _Statement_tryBlock_2 
    = tf.constructor(typestore,_Statement,"tryBlock",_Statement,"tryBody",tf.listType(_Statement),"catchHandlers");
  private static final Type _Statement_do_2 
    = tf.constructor(typestore,_Statement,"do",_Statement,"body",_Expression,"condition");
  
  
  private static final Type _Modifier_override_0 
    = tf.constructor(typestore,_Modifier,"override");
  private static final Type _Modifier_captDefByCopy_0 
    = tf.constructor(typestore,_Modifier,"captDefByCopy");
  private static final Type _Modifier_public_0 
    = tf.constructor(typestore,_Modifier,"public");
  private static final Type _Modifier_typename_0 
    = tf.constructor(typestore,_Modifier,"typename");
  private static final Type _Modifier_mutable_0 
    = tf.constructor(typestore,_Modifier,"mutable");
  private static final Type _Modifier_threadLocal_0 
    = tf.constructor(typestore,_Modifier,"threadLocal");
  private static final Type _Modifier_extern_0 
    = tf.constructor(typestore,_Modifier,"extern");
  private static final Type _Modifier_friend_0 
    = tf.constructor(typestore,_Modifier,"friend");
  private static final Type _Modifier_unsigned_0 
    = tf.constructor(typestore,_Modifier,"unsigned");
  private static final Type _Modifier_final_0 
    = tf.constructor(typestore,_Modifier,"final");
  private static final Type _Modifier_complex_0 
    = tf.constructor(typestore,_Modifier,"complex");
  private static final Type _Modifier_protected_0 
    = tf.constructor(typestore,_Modifier,"protected");
  private static final Type _Modifier_static_0 
    = tf.constructor(typestore,_Modifier,"static");
  private static final Type _Modifier_virtual_0 
    = tf.constructor(typestore,_Modifier,"virtual");
  private static final Type _Modifier_typedef_0 
    = tf.constructor(typestore,_Modifier,"typedef");
  private static final Type _Modifier_const_0 
    = tf.constructor(typestore,_Modifier,"const");
  private static final Type _Modifier_register_0 
    = tf.constructor(typestore,_Modifier,"register");
  private static final Type _Modifier_private_0 
    = tf.constructor(typestore,_Modifier,"private");
  private static final Type _Modifier_signed_0 
    = tf.constructor(typestore,_Modifier,"signed");
  private static final Type _Modifier_restrict_0 
    = tf.constructor(typestore,_Modifier,"restrict");
  private static final Type _Modifier_long_0 
    = tf.constructor(typestore,_Modifier,"long");
  private static final Type _Modifier_volatile_0 
    = tf.constructor(typestore,_Modifier,"volatile");
  private static final Type _Modifier_short_0 
    = tf.constructor(typestore,_Modifier,"short");
  private static final Type _Modifier_inline_0 
    = tf.constructor(typestore,_Modifier,"inline");
  private static final Type _Modifier_imaginary_0 
    = tf.constructor(typestore,_Modifier,"imaginary");
  private static final Type _Modifier_constexpr_0 
    = tf.constructor(typestore,_Modifier,"constexpr");
  private static final Type _Modifier_longlong_0 
    = tf.constructor(typestore,_Modifier,"longlong");
  private static final Type _Modifier_explicit_0 
    = tf.constructor(typestore,_Modifier,"explicit");
  private static final Type _Modifier_captDefUnspecified_0 
    = tf.constructor(typestore,_Modifier,"captDefUnspecified");
  private static final Type _Modifier_modAuto_0 
    = tf.constructor(typestore,_Modifier,"modAuto");
  private static final Type _Modifier_captDefByReference_0 
    = tf.constructor(typestore,_Modifier,"captDefByReference");
  private static final Type _Modifier_unspecifiedInheritance_0 
    = tf.constructor(typestore,_Modifier,"unspecifiedInheritance");
  private static final Type _Modifier_pureVirtual_0 
    = tf.constructor(typestore,_Modifier,"pureVirtual");
  
  
  private static final Type _TypeSymbol_typedef_1 
    = tf.constructor(typestore,_TypeSymbol,"typedef",_TypeSymbol,"type");
  private static final Type _TypeSymbol_problemType_1 
    = tf.constructor(typestore,_TypeSymbol,"problemType",tf.stringType(),"msg");
  private static final Type _TypeSymbol_union_1 
    = tf.constructor(typestore,_TypeSymbol,"union",tf.sourceLocationType(),"decl");
  private static final Type _TypeSymbol_float_0 
    = tf.constructor(typestore,_TypeSymbol,"float");
  private static final Type _TypeSymbol_unspecified_0 
    = tf.constructor(typestore,_TypeSymbol,"unspecified");
  private static final Type _TypeSymbol_eUnionTemplate_2 
    = tf.constructor(typestore,_TypeSymbol,"eUnionTemplate",tf.sourceLocationType(),"decl",tf.listType(tf.sourceLocationType()),"templateParameters");
  private static final Type _TypeSymbol_class_1 
    = tf.constructor(typestore,_TypeSymbol,"class",tf.sourceLocationType(),"decl");
  private static final Type _TypeSymbol_eClassTemplate_2 
    = tf.constructor(typestore,_TypeSymbol,"eClassTemplate",tf.sourceLocationType(),"decl",tf.listType(tf.sourceLocationType()),"templateParameters");
  private static final Type _TypeSymbol_templateTypeParameter_2 
    = tf.constructor(typestore,_TypeSymbol,"templateTypeParameter",tf.sourceLocationType(),"owner",tf.sourceLocationType(),"decl");
  private static final Type _TypeSymbol_cClassTemplate_2 
    = tf.constructor(typestore,_TypeSymbol,"cClassTemplate",tf.sourceLocationType(),"decl",tf.listType(tf.sourceLocationType()),"templateParameters");
  private static final Type _TypeSymbol_functionType_2 
    = tf.constructor(typestore,_TypeSymbol,"functionType",_TypeSymbol,"returnType",tf.listType(_TypeSymbol),"parameterTypes");
  private static final Type _TypeSymbol_functionTypeVarArgs_2 
    = tf.constructor(typestore,_TypeSymbol,"functionTypeVarArgs",_TypeSymbol,"returnType",tf.listType(_TypeSymbol),"parameterTypes");
  private static final Type _TypeSymbol_eStructTemplate_2 
    = tf.constructor(typestore,_TypeSymbol,"eStructTemplate",tf.sourceLocationType(),"decl",tf.listType(tf.sourceLocationType()),"templateParameters");
  private static final Type _TypeSymbol_templateTemplate_2 
    = tf.constructor(typestore,_TypeSymbol,"templateTemplate",_TypeSymbol,"child",tf.listType(tf.sourceLocationType()),"templateParameters");
  private static final Type _TypeSymbol_noType_0 
    = tf.constructor(typestore,_TypeSymbol,"noType");
  private static final Type _TypeSymbol_float128_0 
    = tf.constructor(typestore,_TypeSymbol,"float128");
  private static final Type _TypeSymbol_variableTemplate_2 
    = tf.constructor(typestore,_TypeSymbol,"variableTemplate",tf.sourceLocationType(),"decl",tf.listType(tf.sourceLocationType()),"templateParameters");
  private static final Type _TypeSymbol_unknownMemberClass_2 
    = tf.constructor(typestore,_TypeSymbol,"unknownMemberClass",tf.sourceLocationType(),"owner",tf.stringType(),"name");
  private static final Type _TypeSymbol_char16_0 
    = tf.constructor(typestore,_TypeSymbol,"char16");
  private static final Type _TypeSymbol_functionTemplate_2 
    = tf.constructor(typestore,_TypeSymbol,"functionTemplate",tf.sourceLocationType(),"decl",tf.listType(tf.sourceLocationType()),"templateParameters");
  private static final Type _TypeSymbol_cStructTemplate_2 
    = tf.constructor(typestore,_TypeSymbol,"cStructTemplate",tf.sourceLocationType(),"decl",tf.listType(tf.sourceLocationType()),"templateParameters");
  private static final Type _TypeSymbol_typeOfDependentExpression_1 
    = tf.constructor(typestore,_TypeSymbol,"typeOfDependentExpression",tf.sourceLocationType(),"src");
  private static final Type _TypeSymbol_array_1 
    = tf.constructor(typestore,_TypeSymbol,"array",_TypeSymbol,"baseType");
  private static final Type _TypeSymbol_qualifierType_2 
    = tf.constructor(typestore,_TypeSymbol,"qualifierType",tf.listType(_TypeModifier),"modifiers",_TypeSymbol,"type");
  private static final Type _TypeSymbol_unresolved_0 
    = tf.constructor(typestore,_TypeSymbol,"unresolved");
  private static final Type _TypeSymbol_double_0 
    = tf.constructor(typestore,_TypeSymbol,"double");
  private static final Type _TypeSymbol_decimal32_0 
    = tf.constructor(typestore,_TypeSymbol,"decimal32");
  private static final Type _TypeSymbol_enumerationSpecialization_2 
    = tf.constructor(typestore,_TypeSymbol,"enumerationSpecialization",tf.sourceLocationType(),"specializedBinding",tf.listType(_TypeSymbol),"templateArguments");
  private static final Type _TypeSymbol_char32_0 
    = tf.constructor(typestore,_TypeSymbol,"char32");
  private static final Type _TypeSymbol_enumeration_1 
    = tf.constructor(typestore,_TypeSymbol,"enumeration",tf.sourceLocationType(),"decl");
  private static final Type _TypeSymbol_typeContainer_1 
    = tf.constructor(typestore,_TypeSymbol,"typeContainer",_TypeSymbol,"type");
  private static final Type _TypeSymbol_void_0 
    = tf.constructor(typestore,_TypeSymbol,"void");
  private static final Type _TypeSymbol_char_0 
    = tf.constructor(typestore,_TypeSymbol,"char");
  private static final Type _TypeSymbol_functionSetTypePointer_2 
    = tf.constructor(typestore,_TypeSymbol,"functionSetTypePointer",tf.sourceLocationType(),"decl",tf.listType(_TypeSymbol),"templateArguments");
  private static final Type _TypeSymbol_referenceType_1 
    = tf.constructor(typestore,_TypeSymbol,"referenceType",_TypeSymbol,"type");
  private static final Type _TypeSymbol_boolean_0 
    = tf.constructor(typestore,_TypeSymbol,"boolean");
  private static final Type _TypeSymbol_int128_0 
    = tf.constructor(typestore,_TypeSymbol,"int128");
  private static final Type _TypeSymbol_cUnionTemplate_2 
    = tf.constructor(typestore,_TypeSymbol,"cUnionTemplate",tf.sourceLocationType(),"decl",tf.listType(tf.sourceLocationType()),"templateParameters");
  private static final Type _TypeSymbol_functionSetType_2 
    = tf.constructor(typestore,_TypeSymbol,"functionSetType",tf.sourceLocationType(),"decl",tf.listType(_TypeSymbol),"templateArguments");
  private static final Type _TypeSymbol_implicitTemplateTypeParameter_2 
    = tf.constructor(typestore,_TypeSymbol,"implicitTemplateTypeParameter",tf.sourceLocationType(),"owner",tf.integerType(),"position");
  private static final Type _TypeSymbol_pointerType_2 
    = tf.constructor(typestore,_TypeSymbol,"pointerType",tf.listType(_TypeModifier),"modifiers",_TypeSymbol,"type");
  private static final Type _TypeSymbol_eEnumTemplate_2 
    = tf.constructor(typestore,_TypeSymbol,"eEnumTemplate",tf.sourceLocationType(),"decl",tf.listType(tf.sourceLocationType()),"templateParameters");
  private static final Type _TypeSymbol_wchar_0 
    = tf.constructor(typestore,_TypeSymbol,"wchar");
  private static final Type _TypeSymbol_any_0 
    = tf.constructor(typestore,_TypeSymbol,"any");
  private static final Type _TypeSymbol_classSpecialization_2 
    = tf.constructor(typestore,_TypeSymbol,"classSpecialization",tf.sourceLocationType(),"decl",tf.listType(_TypeSymbol),"templateArguments");
  private static final Type _TypeSymbol_parameterPackType_1 
    = tf.constructor(typestore,_TypeSymbol,"parameterPackType",_TypeSymbol,"type");
  private static final Type _TypeSymbol_decimal64_0 
    = tf.constructor(typestore,_TypeSymbol,"decimal64");
  private static final Type _TypeSymbol_int_0 
    = tf.constructor(typestore,_TypeSymbol,"int");
  private static final Type _TypeSymbol_struct_1 
    = tf.constructor(typestore,_TypeSymbol,"struct",tf.listType(_TypeSymbol),"fields");
  private static final Type _TypeSymbol_deferredClassInstance_1 
    = tf.constructor(typestore,_TypeSymbol,"deferredClassInstance",tf.stringType(),"name");
  private static final Type _TypeSymbol_array_2 
    = tf.constructor(typestore,_TypeSymbol,"array",_TypeSymbol,"baseType",tf.integerType(),"size");
  private static final Type _TypeSymbol_aliasTemplate_2 
    = tf.constructor(typestore,_TypeSymbol,"aliasTemplate",tf.sourceLocationType(),"decl",tf.listType(tf.sourceLocationType()),"templateParameters");
  private static final Type _TypeSymbol_nullPtr_0 
    = tf.constructor(typestore,_TypeSymbol,"nullPtr");
  private static final Type _TypeSymbol_decimal128_0 
    = tf.constructor(typestore,_TypeSymbol,"decimal128");
  private static final Type _TypeSymbol_basicType_2 
    = tf.constructor(typestore,_TypeSymbol,"basicType",tf.listType(_TypeModifier),"modifiers",_TypeSymbol,"baseType");
  private static final Type _TypeSymbol_problemBinding_0 
    = tf.constructor(typestore,_TypeSymbol,"problemBinding");
  
  
  private static final Type _Attribute_alignmentSpecifier_1 
    = tf.constructor(typestore,_Attribute,"alignmentSpecifier",_Expression,"typeIdOrExpression");
  private static final Type _Attribute_attribute_1 
    = tf.constructor(typestore,_Attribute,"attribute",tf.stringType(),"name");
  private static final Type _Attribute_attributeSpecifier_1 
    = tf.constructor(typestore,_Attribute,"attributeSpecifier",tf.listType(_Attribute),"attributes");
  private static final Type _Attribute_attribute_2 
    = tf.constructor(typestore,_Attribute,"attribute",tf.stringType(),"name",tf.stringType(),"argumentClause");
  
  
  private static final Type _TypeModifier_unsigned_0 
    = tf.constructor(typestore,_TypeModifier,"unsigned");
  private static final Type _TypeModifier_complex_0 
    = tf.constructor(typestore,_TypeModifier,"complex");
  private static final Type _TypeModifier_imaginary_0 
    = tf.constructor(typestore,_TypeModifier,"imaginary");
  private static final Type _TypeModifier_longlong_0 
    = tf.constructor(typestore,_TypeModifier,"longlong");
  private static final Type _TypeModifier_const_0 
    = tf.constructor(typestore,_TypeModifier,"const");
  private static final Type _TypeModifier_static_0 
    = tf.constructor(typestore,_TypeModifier,"static");
  private static final Type _TypeModifier_short_0 
    = tf.constructor(typestore,_TypeModifier,"short");
  private static final Type _TypeModifier_volatile_0 
    = tf.constructor(typestore,_TypeModifier,"volatile");
  private static final Type _TypeModifier_long_0 
    = tf.constructor(typestore,_TypeModifier,"long");
  private static final Type _TypeModifier_restrict_0 
    = tf.constructor(typestore,_TypeModifier,"restrict");
  private static final Type _TypeModifier_signed_0 
    = tf.constructor(typestore,_TypeModifier,"signed");
  
  
  private static final Type _M3_m3_1 
    = tf.constructor(typestore,_M3,"m3",tf.sourceLocationType(),"id");
  
  
  private static final Type _Name_conversionName_2 
    = tf.constructor(typestore,_Name,"conversionName",tf.stringType(),"value",_Expression,"typeId");
  private static final Type _Name_qualifiedName_2 
    = tf.constructor(typestore,_Name,"qualifiedName",tf.listType(_Name),"qualifiers",_Name,"lastName");
  private static final Type _Name_name_1 
    = tf.constructor(typestore,_Name,"name",tf.stringType(),"value");
  private static final Type _Name_operatorName_1 
    = tf.constructor(typestore,_Name,"operatorName",tf.stringType(),"value");
  private static final Type _Name_abstractEmptyName_0 
    = tf.constructor(typestore,_Name,"abstractEmptyName");
  private static final Type _Name_templateId_2 
    = tf.constructor(typestore,_Name,"templateId",_Name,"name",tf.listType(_Expression),"argumentTypes");
  
   
  
  public IConstructor Declarator_functionDeclaratorNested(IList $pointerOperators, IList $modifiers, IConstructor $declarator, IList $parameters, IList $virtSpecifiers, IConstructor $initializer, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
      
    if (!$parameters.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $parameters.getType() + " for $parameters:" + $parameters);
    }
      
    if (!$virtSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $virtSpecifiers.getType() + " for $virtSpecifiers:" + $virtSpecifiers);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_functionDeclaratorNested_6 , $pointerOperators, $modifiers, $declarator, $parameters, $virtSpecifiers, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_functionDeclarator(IList $pointerOperators, IConstructor $name, IList $parameters, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$parameters.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $parameters.getType() + " for $parameters:" + $parameters);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_functionDeclarator_3 , $pointerOperators, $name, $parameters).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_functionDeclaratorWithES(IList $pointerOperators, IList $modifiers, IConstructor $name, IList $parameters, IList $virtSpecifiers, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$parameters.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $parameters.getType() + " for $parameters:" + $parameters);
    }
      
    if (!$virtSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $virtSpecifiers.getType() + " for $virtSpecifiers:" + $virtSpecifiers);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_functionDeclaratorWithES_5 , $pointerOperators, $modifiers, $name, $parameters, $virtSpecifiers).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_functionDeclaratorNoexcept(IList $pointerOperators, IList $modifiers, IConstructor $name, IList $parameters, IList $virtSpecifiers, IConstructor $noexceptExpression, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$parameters.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $parameters.getType() + " for $parameters:" + $parameters);
    }
      
    if (!$virtSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $virtSpecifiers.getType() + " for $virtSpecifiers:" + $virtSpecifiers);
    }
      
    if (!$noexceptExpression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $noexceptExpression.getType() + " for $noexceptExpression:" + $noexceptExpression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_functionDeclaratorNoexcept_6 , $pointerOperators, $modifiers, $name, $parameters, $virtSpecifiers, $noexceptExpression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_arrayDeclaratorNested(IList $pointerOperators, IConstructor $declarator, IList $arrayModifier, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
      
    if (!$arrayModifier.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $arrayModifier.getType() + " for $arrayModifier:" + $arrayModifier);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_arrayDeclaratorNested_3 , $pointerOperators, $declarator, $arrayModifier).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_functionDeclarator(IList $pointerOperators, IList $modifiers, IConstructor $name, IList $parameters, IList $virtSpecifiers, IConstructor $trailingReturnType, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$parameters.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $parameters.getType() + " for $parameters:" + $parameters);
    }
      
    if (!$virtSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $virtSpecifiers.getType() + " for $virtSpecifiers:" + $virtSpecifiers);
    }
      
    if (!$trailingReturnType.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $trailingReturnType.getType() + " for $trailingReturnType:" + $trailingReturnType);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_functionDeclarator_6 , $pointerOperators, $modifiers, $name, $parameters, $virtSpecifiers, $trailingReturnType).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_declarator(IList $pointerOperators, IConstructor $name, IConstructor $initializer, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_declarator_3 , $pointerOperators, $name, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_arrayDeclarator(IList $pointerOperators, IConstructor $name, IList $arrayModifier, IConstructor $initializer, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$arrayModifier.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $arrayModifier.getType() + " for $arrayModifier:" + $arrayModifier);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_arrayDeclarator_4 , $pointerOperators, $name, $arrayModifier, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_declarator(IList $pointerOperators, IConstructor $name, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_declarator_2 , $pointerOperators, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_missingDeclarator(ISourceLocation $loc, ISourceLocation $decl) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_missingDeclarator_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_functionDeclaratorWithES(IList $pointerOperators, IList $modifiers, IConstructor $name, IList $parameters, IList $virtSpecifiers, IList $exceptionSpecification, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$parameters.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $parameters.getType() + " for $parameters:" + $parameters);
    }
      
    if (!$virtSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $virtSpecifiers.getType() + " for $virtSpecifiers:" + $virtSpecifiers);
    }
      
    if (!$exceptionSpecification.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $exceptionSpecification.getType() + " for $exceptionSpecification:" + $exceptionSpecification);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_functionDeclaratorWithES_6 , $pointerOperators, $modifiers, $name, $parameters, $virtSpecifiers, $exceptionSpecification).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_fieldDeclarator(IList $pointerOperators, IConstructor $name, IConstructor $bitFieldSize, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$bitFieldSize.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $bitFieldSize.getType() + " for $bitFieldSize:" + $bitFieldSize);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_fieldDeclarator_3 , $pointerOperators, $name, $bitFieldSize).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_arrayDeclarator(IList $pointerOperators, IConstructor $name, IList $arrayModifier, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$arrayModifier.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $arrayModifier.getType() + " for $arrayModifier:" + $arrayModifier);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_arrayDeclarator_3 , $pointerOperators, $name, $arrayModifier).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_functionDeclarator(IList $pointerOperators, IList $modifiers, IConstructor $name, IList $parameters, IList $virtSpecifiers, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$parameters.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $parameters.getType() + " for $parameters:" + $parameters);
    }
      
    if (!$virtSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $virtSpecifiers.getType() + " for $virtSpecifiers:" + $virtSpecifiers);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_functionDeclarator_5 , $pointerOperators, $modifiers, $name, $parameters, $virtSpecifiers).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_fieldDeclarator(IList $pointerOperators, IConstructor $name, IConstructor $bitFieldSize, IConstructor $initializer, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$bitFieldSize.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $bitFieldSize.getType() + " for $bitFieldSize:" + $bitFieldSize);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_fieldDeclarator_4 , $pointerOperators, $name, $bitFieldSize, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_functionDeclaratorNested(IList $pointerOperators, IList $modifiers, IConstructor $declarator, IList $parameters, IList $virtSpecifiers, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
      
    if (!$parameters.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $parameters.getType() + " for $parameters:" + $parameters);
    }
      
    if (!$virtSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $virtSpecifiers.getType() + " for $virtSpecifiers:" + $virtSpecifiers);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_functionDeclaratorNested_5 , $pointerOperators, $modifiers, $declarator, $parameters, $virtSpecifiers).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declarator_arrayDeclaratorNested(IList $pointerOperators, IConstructor $declarator, IList $arrayModifier, IConstructor $initializer, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$pointerOperators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $pointerOperators.getType() + " for $pointerOperators:" + $pointerOperators);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
      
    if (!$arrayModifier.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $arrayModifier.getType() + " for $arrayModifier:" + $arrayModifier);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declarator_arrayDeclaratorNested_4 , $pointerOperators, $declarator, $arrayModifier, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  
  public IConstructor DeclSpecifier_enum(IList $modifiers, IConstructor $baseType, IConstructor $name, IList $enumerators, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$baseType.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $baseType.getType() + " for $baseType:" + $baseType);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$enumerators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $enumerators.getType() + " for $enumerators:" + $enumerators);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_enum_4 , $modifiers, $baseType, $name, $enumerators).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_etsEnum(IList $modifiers, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_etsEnum_2 , $modifiers, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_struct(IList $modifiers, IConstructor $name, IList $baseSpecifiers, IList $members, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$baseSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $baseSpecifiers.getType() + " for $baseSpecifiers:" + $baseSpecifiers);
    }
      
    if (!$members.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $members.getType() + " for $members:" + $members);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_struct_4 , $modifiers, $name, $baseSpecifiers, $members).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_class(IList $modifiers, IConstructor $name, IList $members, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$members.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $members.getType() + " for $members:" + $members);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_class_3 , $modifiers, $name, $members).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_classFinal(IList $modifiers, IConstructor $name, IList $baseSpecifiers, IList $members, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$baseSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $baseSpecifiers.getType() + " for $baseSpecifiers:" + $baseSpecifiers);
    }
      
    if (!$members.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $members.getType() + " for $members:" + $members);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_classFinal_4 , $modifiers, $name, $baseSpecifiers, $members).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_struct(IList $modifiers, IConstructor $name, IList $members, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$members.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $members.getType() + " for $members:" + $members);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_struct_3 , $modifiers, $name, $members).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_union(IList $modifiers, IConstructor $name, IList $members, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$members.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $members.getType() + " for $members:" + $members);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_union_3 , $modifiers, $name, $members).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_declSpecifier(IList $modifiers, IConstructor $type, IList $attributes, ISourceLocation $loc) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$type.getType().isSubtypeOf(_Type)) {
      throw new IllegalArgumentException("Expected " + _Type + " but got " + $type.getType() + " for $type:" + $type);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_DeclSpecifier_declSpecifier_2 , $modifiers, $type).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_union(IList $modifiers, IConstructor $name, IList $baseSpecifiers, IList $members, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$baseSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $baseSpecifiers.getType() + " for $baseSpecifiers:" + $baseSpecifiers);
    }
      
    if (!$members.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $members.getType() + " for $members:" + $members);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_union_4 , $modifiers, $name, $baseSpecifiers, $members).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_etsStruct(IList $modifiers, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_etsStruct_2 , $modifiers, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_declSpecifier(IList $modifiers, IConstructor $type, IConstructor $expression, IList $attributes, ISourceLocation $loc) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$type.getType().isSubtypeOf(_Type)) {
      throw new IllegalArgumentException("Expected " + _Type + " but got " + $type.getType() + " for $type:" + $type);
    }
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_DeclSpecifier_declSpecifier_3 , $modifiers, $type, $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_msThrowEllipsis(ISourceLocation $loc, ISourceLocation $decl) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_msThrowEllipsis_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_enumScoped(IList $modifiers, IConstructor $name, IList $enumerators, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$enumerators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $enumerators.getType() + " for $enumerators:" + $enumerators);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_enumScoped_3 , $modifiers, $name, $enumerators).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_enumOpaque(IList $modifiers, IConstructor $baseType, IConstructor $name, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$baseType.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $baseType.getType() + " for $baseType:" + $baseType);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_enumOpaque_3 , $modifiers, $baseType, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_namedTypeSpecifier(IList $modifiers, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_namedTypeSpecifier_2 , $modifiers, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_class(IList $modifiers, IConstructor $name, IList $baseSpecifiers, IList $members, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$baseSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $baseSpecifiers.getType() + " for $baseSpecifiers:" + $baseSpecifiers);
    }
      
    if (!$members.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $members.getType() + " for $members:" + $members);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_class_4 , $modifiers, $name, $baseSpecifiers, $members).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_etsUnion(IList $modifiers, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_etsUnion_2 , $modifiers, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_unionFinal(IList $modifiers, IConstructor $name, IList $baseSpecifiers, IList $members, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$baseSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $baseSpecifiers.getType() + " for $baseSpecifiers:" + $baseSpecifiers);
    }
      
    if (!$members.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $members.getType() + " for $members:" + $members);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_unionFinal_4 , $modifiers, $name, $baseSpecifiers, $members).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_enumScoped(IList $modifiers, IConstructor $baseType, IConstructor $name, IList $enumerators, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$baseType.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $baseType.getType() + " for $baseType:" + $baseType);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$enumerators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $enumerators.getType() + " for $enumerators:" + $enumerators);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_enumScoped_4 , $modifiers, $baseType, $name, $enumerators).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_etsClass(IList $modifiers, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_etsClass_2 , $modifiers, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_enumScopedOpaque(IList $modifiers, IConstructor $name, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_enumScopedOpaque_2 , $modifiers, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_structFinal(IList $modifiers, IConstructor $name, IList $baseSpecifiers, IList $members, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$baseSpecifiers.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $baseSpecifiers.getType() + " for $baseSpecifiers:" + $baseSpecifiers);
    }
      
    if (!$members.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $members.getType() + " for $members:" + $members);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_structFinal_4 , $modifiers, $name, $baseSpecifiers, $members).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_enum(IList $modifiers, IConstructor $name, IList $enumerators, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$enumerators.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $enumerators.getType() + " for $enumerators:" + $enumerators);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_enum_3 , $modifiers, $name, $enumerators).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor DeclSpecifier_enumScopedOpaque(IList $modifiers, IConstructor $baseType, IConstructor $name, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$baseType.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $baseType.getType() + " for $baseType:" + $baseType);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_DeclSpecifier_enumScopedOpaque_3 , $modifiers, $baseType, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  
  public IConstructor Declaration_sttClass(IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_sttClass_1 , $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_namespaceDefinitionInline(IConstructor $name, IList $declarations, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$declarations.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $declarations.getType() + " for $declarations:" + $declarations);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_namespaceDefinitionInline_2 , $name, $declarations).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_asmDeclaration(String $assembly, ISourceLocation $loc) {
      
    if (!vf.string($assembly).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($assembly).getType() + " for vf.string($assembly):" + vf.string($assembly));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_asmDeclaration_1 , vf.string($assembly)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_reference(IList $attributes, ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_reference_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_template(IList $parameters, IConstructor $declaration, IConstructor $type, ISourceLocation $loc) {
      
    if (!$parameters.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $parameters.getType() + " for $parameters:" + $parameters);
    }
      
    if (!$declaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $declaration.getType() + " for $declaration:" + $declaration);
    }
      
    if (!$type.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $type.getType() + " for $type:" + $type);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_template_3 , $parameters, $declaration, $type).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_explicitTemplateInstantiation(IConstructor $modifier, IConstructor $declaration, ISourceLocation $loc) {
      
    if (!$modifier.getType().isSubtypeOf(_Modifier)) {
      throw new IllegalArgumentException("Expected " + _Modifier + " but got " + $modifier.getType() + " for $modifier:" + $modifier);
    }
      
    if (!$declaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $declaration.getType() + " for $declaration:" + $declaration);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_explicitTemplateInstantiation_2 , $modifier, $declaration).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_functionDefinition(IConstructor $declSpecifier, IConstructor $declarator, IList $memberInitializer, IConstructor $body, IList $attributes, ISourceLocation $loc) {
      
    if (!$declSpecifier.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $declSpecifier.getType() + " for $declSpecifier:" + $declSpecifier);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
      
    if (!$memberInitializer.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $memberInitializer.getType() + " for $memberInitializer:" + $memberInitializer);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_functionDefinition_4 , $declSpecifier, $declarator, $memberInitializer, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_pointerToMember(IList $modifiers, IConstructor $nestedName, IList $attributes, ISourceLocation $loc) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$nestedName.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $nestedName.getType() + " for $nestedName:" + $nestedName);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_pointerToMember_2 , $modifiers, $nestedName).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_translationUnit(IList $declarations, ISourceLocation $loc) {
      
    if (!$declarations.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $declarations.getType() + " for $declarations:" + $declarations);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_translationUnit_1 , $declarations).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_parameter(IConstructor $declSpecifier, IConstructor $declarator, ISourceLocation $loc) {
      
    if (!$declSpecifier.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $declSpecifier.getType() + " for $declSpecifier:" + $declSpecifier);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_parameter_2 , $declSpecifier, $declarator).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_enumerator(IConstructor $name, IConstructor $value, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$value.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $value.getType() + " for $value:" + $value);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_enumerator_2 , $name, $value).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_varArgs(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_varArgs_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_simpleDeclaration(IConstructor $declSpecifier, IList $declarators, IList $attributes, ISourceLocation $loc) {
      
    if (!$declSpecifier.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $declSpecifier.getType() + " for $declSpecifier:" + $declSpecifier);
    }
      
    if (!$declarators.getType().isSubtypeOf(tf.listType(_Declarator))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declarator) + " but got " + $declarators.getType() + " for $declarators:" + $declarators);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_simpleDeclaration_2 , $declSpecifier, $declarators).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_sttClass(IConstructor $name, IConstructor $defaultType, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$defaultType.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $defaultType.getType() + " for $defaultType:" + $defaultType);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_sttClass_2 , $name, $defaultType).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_linkageSpecification(String $literal, IList $declarations, ISourceLocation $loc) {
      
    if (!vf.string($literal).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($literal).getType() + " for vf.string($literal):" + vf.string($literal));
    }
      
    if (!$declarations.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $declarations.getType() + " for $declarations:" + $declarations);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_linkageSpecification_2 , vf.string($literal), $declarations).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_namespaceDefinition(IConstructor $name, IList $declarations, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$declarations.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $declarations.getType() + " for $declarations:" + $declarations);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_namespaceDefinition_2 , $name, $declarations).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_baseSpecifier(IList $modifiers, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_baseSpecifier_2 , $modifiers, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_explicitTemplateInstantiation(IConstructor $declaration, ISourceLocation $loc) {
      
    if (!$declaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $declaration.getType() + " for $declaration:" + $declaration);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_explicitTemplateInstantiation_1 , $declaration).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_explicitTemplateSpecialization(IConstructor $declaration, ISourceLocation $loc) {
      
    if (!$declaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $declaration.getType() + " for $declaration:" + $declaration);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_explicitTemplateSpecialization_1 , $declaration).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_tttParameter(IList $nestedParameters, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$nestedParameters.getType().isSubtypeOf(tf.listType(_Declaration))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Declaration) + " but got " + $nestedParameters.getType() + " for $nestedParameters:" + $nestedParameters);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_tttParameter_2 , $nestedParameters, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_rvalueReference(IList $attributes, ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_rvalueReference_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_enumerator(IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_enumerator_1 , $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_namespaceAlias(IConstructor $alias, IConstructor $mapping, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$alias.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $alias.getType() + " for $alias:" + $alias);
    }
      
    if (!$mapping.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $mapping.getType() + " for $mapping:" + $mapping);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_namespaceAlias_2 , $alias, $mapping).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_staticAssert(IConstructor $condition, IConstructor $message, ISourceLocation $loc) {
      
    if (!$condition.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $condition.getType() + " for $condition:" + $condition);
    }
      
    if (!$message.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $message.getType() + " for $message:" + $message);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_staticAssert_2 , $condition, $message).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_alias(IConstructor $alias, IConstructor $mappingTypeId, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$alias.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $alias.getType() + " for $alias:" + $alias);
    }
      
    if (!$mappingTypeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $mappingTypeId.getType() + " for $mappingTypeId:" + $mappingTypeId);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_alias_2 , $alias, $mappingTypeId).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_visibilityLabel(IConstructor $visibility, ISourceLocation $loc) {
      
    if (!$visibility.getType().isSubtypeOf(_Modifier)) {
      throw new IllegalArgumentException("Expected " + _Modifier + " but got " + $visibility.getType() + " for $visibility:" + $visibility);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_visibilityLabel_1 , $visibility).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_functionWithTryBlockDefinition(IConstructor $declSpecifier, IConstructor $declarator, IList $memberInitializers, IConstructor $sbody, IList $catchHandlers, IList $attributes, ISourceLocation $loc) {
      
    if (!$declSpecifier.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $declSpecifier.getType() + " for $declSpecifier:" + $declSpecifier);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
      
    if (!$memberInitializers.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $memberInitializers.getType() + " for $memberInitializers:" + $memberInitializers);
    }
      
    if (!$sbody.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $sbody.getType() + " for $sbody:" + $sbody);
    }
      
    if (!$catchHandlers.getType().isSubtypeOf(tf.listType(_Statement))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Statement) + " but got " + $catchHandlers.getType() + " for $catchHandlers:" + $catchHandlers);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_functionWithTryBlockDefinition_5 , $declSpecifier, $declarator, $memberInitializers, $sbody, $catchHandlers).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_parameter(IConstructor $declSpecifier, ISourceLocation $loc) {
      
    if (!$declSpecifier.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $declSpecifier.getType() + " for $declSpecifier:" + $declSpecifier);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_parameter_1 , $declSpecifier).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_sttTypename(IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_sttTypename_1 , $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_virtSpecifier(IConstructor $modifier, ISourceLocation $loc) {
      
    if (!$modifier.getType().isSubtypeOf(_Modifier)) {
      throw new IllegalArgumentException("Expected " + _Modifier + " but got " + $modifier.getType() + " for $modifier:" + $modifier);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_virtSpecifier_1 , $modifier).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_defaultedFunctionDefinition(IConstructor $declSpecifier, IList $memberInitializer, IConstructor $declarator, IList $attributes, ISourceLocation $loc) {
      
    if (!$declSpecifier.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $declSpecifier.getType() + " for $declSpecifier:" + $declSpecifier);
    }
      
    if (!$memberInitializer.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $memberInitializer.getType() + " for $memberInitializer:" + $memberInitializer);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_defaultedFunctionDefinition_3 , $declSpecifier, $memberInitializer, $declarator).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_usingDeclaration(IList $modifiers, IConstructor $name, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_usingDeclaration_2 , $modifiers, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_pointer(IList $modifiers, IList $attributes, ISourceLocation $loc) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_pointer_1 , $modifiers).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_usingDirective(IConstructor $qualifiedName, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$qualifiedName.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $qualifiedName.getType() + " for $qualifiedName:" + $qualifiedName);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_usingDirective_1 , $qualifiedName).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_deletedFunctionDefinition(IConstructor $declSpecifier, IList $memberInitializer, IConstructor $declarator, IList $attributes, ISourceLocation $loc) {
      
    if (!$declSpecifier.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $declSpecifier.getType() + " for $declSpecifier:" + $declSpecifier);
    }
      
    if (!$memberInitializer.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $memberInitializer.getType() + " for $memberInitializer:" + $memberInitializer);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_deletedFunctionDefinition_3 , $declSpecifier, $memberInitializer, $declarator).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_functionDefinition(IConstructor $returnSpec, IConstructor $declarator, IConstructor $body, IList $attributes, ISourceLocation $loc) {
      
    if (!$returnSpec.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $returnSpec.getType() + " for $returnSpec:" + $returnSpec);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_functionDefinition_3 , $returnSpec, $declarator, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_baseSpecifier(IList $modifiers, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_baseSpecifier_1 , $modifiers).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_problemDeclaration(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Declaration_problemDeclaration_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Declaration_sttTypename(IConstructor $name, IConstructor $defaultType, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$defaultType.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $defaultType.getType() + " for $defaultType:" + $defaultType);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Declaration_sttTypename_2 , $name, $defaultType).asWithKeywordParameters().setParameters(kwParams);
  }
  
  
  public IConstructor Expression_cast(IConstructor $typeId, IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_cast_2 , $typeId, $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_empty(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_empty_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_postfixIncr(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_postfixIncr_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_newWithArgs(IList $arguments, IConstructor $typeId, IConstructor $initializer, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$arguments.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $arguments.getType() + " for $arguments:" + $arguments);
    }
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_newWithArgs_3 , $arguments, $typeId, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_sizeofParameterPack(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_sizeofParameterPack_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_assign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_assign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_modulo(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_modulo_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_binaryAnd(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_binaryAnd_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_throw(ISourceLocation $loc, IConstructor $typ) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_throw_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_nullptr(ISourceLocation $loc, IConstructor $typ) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_nullptr_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_alignOf(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_alignOf_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_initializerList(IList $clauses, ISourceLocation $loc) {
      
    if (!$clauses.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $clauses.getType() + " for $clauses:" + $clauses);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_initializerList_1 , $clauses).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_globalNew(IConstructor $typeId, IConstructor $initializer, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_globalNew_2 , $typeId, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_simpleTypeConstructor(IConstructor $declSpecifier, IConstructor $initializer, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$declSpecifier.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $declSpecifier.getType() + " for $declSpecifier:" + $declSpecifier);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_simpleTypeConstructor_2 , $declSpecifier, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_dynamicCast(IConstructor $typeId, IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_dynamicCast_2 , $typeId, $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_ellipses(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_ellipses_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_constructorInitializer(IList $arguments, ISourceLocation $loc) {
      
    if (!$arguments.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $arguments.getType() + " for $arguments:" + $arguments);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_constructorInitializer_1 , $arguments).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_reinterpretCast(IConstructor $typeId, IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_reinterpretCast_2 , $typeId, $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_min(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_min_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_arrayRangeDesignator(IConstructor $rangeFloor, IConstructor $rangeCeiling, ISourceLocation $loc) {
      
    if (!$rangeFloor.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rangeFloor.getType() + " for $rangeFloor:" + $rangeFloor);
    }
      
    if (!$rangeCeiling.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rangeCeiling.getType() + " for $rangeCeiling:" + $rangeCeiling);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_arrayRangeDesignator_2 , $rangeFloor, $rangeCeiling).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_notEquals(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_notEquals_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_tilde(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_tilde_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_binaryOrAssign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_binaryOrAssign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_arrayModifier(IConstructor $constExpression, IList $attributes, ISourceLocation $loc) {
      
    if (!$constExpression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $constExpression.getType() + " for $constExpression:" + $constExpression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_arrayModifier_1 , $constExpression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_false(ISourceLocation $loc, IConstructor $typ) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_false_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_sizeof(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_sizeof_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_multiplyAssign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_multiplyAssign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_nyi(String $raw, ISourceLocation $loc) {
      
    if (!vf.string($raw).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($raw).getType() + " for vf.string($raw):" + vf.string($raw));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_nyi_1 , vf.string($raw)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_minus(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_minus_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_new(IConstructor $typeId, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_new_1 , $typeId).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_noexcept(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_noexcept_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_constructorChainInitializer(IConstructor $name, IConstructor $initializer, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Expression_constructorChainInitializer_2 , $name, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_plus(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_plus_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_true(ISourceLocation $loc, IConstructor $typ) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_true_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_typeid(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_typeid_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_charConstant(String $value, ISourceLocation $loc, IConstructor $typ) {
      
    if (!vf.string($value).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($value).getType() + " for vf.string($value):" + vf.string($value));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_charConstant_1 , vf.string($value)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_equals(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_equals_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_minusAssign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_minusAssign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_typeId(IConstructor $declSpecifier, ISourceLocation $loc) {
      
    if (!$declSpecifier.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $declSpecifier.getType() + " for $declSpecifier:" + $declSpecifier);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_typeId_1 , $declSpecifier).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_labelReference(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_labelReference_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_shiftRight(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_shiftRight_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_captureThisPtr(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_captureThisPtr_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_stringLiteral(String $value, ISourceLocation $loc, IConstructor $typ) {
      
    if (!vf.string($value).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($value).getType() + " for vf.string($value):" + vf.string($value));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_stringLiteral_1 , vf.string($value)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_amper(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_amper_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_plus(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_plus_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_binaryXor(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_binaryXor_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_greaterEqual(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_greaterEqual_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_fieldReferencePointerDeref(IConstructor $fieldOwner, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl, IConstructor $typ) {
      
    if (!$fieldOwner.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $fieldOwner.getType() + " for $fieldOwner:" + $fieldOwner);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_fieldReferencePointerDeref_2 , $fieldOwner, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_arraySubscriptExpression(IConstructor $array, IConstructor $argument, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$array.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $array.getType() + " for $array:" + $array);
    }
      
    if (!$argument.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $argument.getType() + " for $argument:" + $argument);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_arraySubscriptExpression_2 , $array, $argument).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_lessThan(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_lessThan_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_functionCall(IConstructor $functionName, IList $arguments, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$functionName.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $functionName.getType() + " for $functionName:" + $functionName);
    }
      
    if (!$arguments.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $arguments.getType() + " for $arguments:" + $arguments);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_functionCall_2 , $functionName, $arguments).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_globalVectoredDelete(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_globalVectoredDelete_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_lessEqual(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_lessEqual_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_minus(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_minus_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_greaterThan(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_greaterThan_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_capture(IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Expression_capture_1 , $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_not(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_not_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_shiftLeftAssign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_shiftLeftAssign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_typeId(IConstructor $declSpecifier, IConstructor $abstractDeclarator, ISourceLocation $loc) {
      
    if (!$declSpecifier.getType().isSubtypeOf(_DeclSpecifier)) {
      throw new IllegalArgumentException("Expected " + _DeclSpecifier + " but got " + $declSpecifier.getType() + " for $declSpecifier:" + $declSpecifier);
    }
      
    if (!$abstractDeclarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $abstractDeclarator.getType() + " for $abstractDeclarator:" + $abstractDeclarator);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_typeId_2 , $declSpecifier, $abstractDeclarator).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_star(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_star_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_divide(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_divide_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_staticCast(IConstructor $typeId, IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_staticCast_2 , $typeId, $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_integerConstant(String $value, ISourceLocation $loc, IConstructor $typ) {
      
    if (!vf.string($value).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($value).getType() + " for vf.string($value):" + vf.string($value));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_integerConstant_1 , vf.string($value)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_vectoredDelete(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_vectoredDelete_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_problemExpression(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_problemExpression_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_newWithArgs(IList $arguments, IConstructor $typeId, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$arguments.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $arguments.getType() + " for $arguments:" + $arguments);
    }
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_newWithArgs_2 , $arguments, $typeId).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_designatedInitializer(IList $designators, IConstructor $operand, ISourceLocation $loc) {
      
    if (!$designators.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $designators.getType() + " for $designators:" + $designators);
    }
      
    if (!$operand.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $operand.getType() + " for $operand:" + $operand);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_designatedInitializer_2 , $designators, $operand).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_floatConstant(String $value, ISourceLocation $loc, IConstructor $typ) {
      
    if (!vf.string($value).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($value).getType() + " for vf.string($value):" + vf.string($value));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_floatConstant_1 , vf.string($value)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_multiply(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_multiply_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_binaryOr(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_binaryOr_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_max(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_max_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_fieldDesignator(IConstructor $fieldName, ISourceLocation $loc) {
      
    if (!$fieldName.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $fieldName.getType() + " for $fieldName:" + $fieldName);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_fieldDesignator_1 , $fieldName).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_globalNewWithArgs(IList $arguments, IConstructor $typeId, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$arguments.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $arguments.getType() + " for $arguments:" + $arguments);
    }
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_globalNewWithArgs_2 , $arguments, $typeId).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_globalDelete(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_globalDelete_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_moduloAssign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_moduloAssign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_binaryAndAssign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_binaryAndAssign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_conditional(IConstructor $condition, IConstructor $positive, IConstructor $negative, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$condition.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $condition.getType() + " for $condition:" + $condition);
    }
      
    if (!$positive.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $positive.getType() + " for $positive:" + $positive);
    }
      
    if (!$negative.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $negative.getType() + " for $negative:" + $negative);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_conditional_3 , $condition, $positive, $negative).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_packExpansion(IConstructor $pattern, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$pattern.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $pattern.getType() + " for $pattern:" + $pattern);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_packExpansion_1 , $pattern).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_expressionList(IList $expressions, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expressions.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $expressions.getType() + " for $expressions:" + $expressions);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_expressionList_1 , $expressions).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_globalNewWithArgs(IList $arguments, IConstructor $typeId, IConstructor $initializer, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$arguments.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $arguments.getType() + " for $arguments:" + $arguments);
    }
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_globalNewWithArgs_3 , $arguments, $typeId, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_delete(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_delete_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_postfixDecr(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_postfixDecr_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_this(ISourceLocation $loc, IConstructor $typ) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_this_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_logicalAnd(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_logicalAnd_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_arrayModifier(IList $attributes, ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_arrayModifier_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_bracketed(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_bracketed_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_logicalOr(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_logicalOr_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_pmDot(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_pmDot_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_pmArrow(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_pmArrow_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_globalNew(IConstructor $typeId, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_globalNew_1 , $typeId).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_prefixIncr(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_prefixIncr_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_fieldReference(IConstructor $fieldOwner, IConstructor $name, ISourceLocation $loc, ISourceLocation $decl, IConstructor $typ) {
      
    if (!$fieldOwner.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $fieldOwner.getType() + " for $fieldOwner:" + $fieldOwner);
    }
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_fieldReference_2 , $fieldOwner, $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_throw(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_throw_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_idExpression(IConstructor $name, ISourceLocation $loc, ISourceLocation $decl, IConstructor $typ) {
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_idExpression_1 , $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_typeIdInitializerExpression(IConstructor $typeId, IConstructor $initializer, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_typeIdInitializerExpression_2 , $typeId, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_arrayDesignator(IConstructor $subscript, ISourceLocation $loc) {
      
    if (!$subscript.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $subscript.getType() + " for $subscript:" + $subscript);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_arrayDesignator_1 , $subscript).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_compoundStatementExpression(IConstructor $compoundStatement, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$compoundStatement.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $compoundStatement.getType() + " for $compoundStatement:" + $compoundStatement);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_compoundStatementExpression_1 , $compoundStatement).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_equalsInitializer(IConstructor $initializer, ISourceLocation $loc) {
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_equalsInitializer_1 , $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_integerLiteral(IValue $number, ISourceLocation $loc) {
      
    if (!$number.getType().isSubtypeOf(tf.integerType())) {
      throw new IllegalArgumentException("Expected " + tf.integerType() + " but got " + $number.getType() + " for $number:" + $number);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Expression_integerLiteral_1 , $number).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_divideAssign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_divideAssign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_captureByRef(IConstructor $name, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Expression_captureByRef_1 , $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_new(IConstructor $typeId, IConstructor $initializer, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_new_2 , $typeId, $initializer).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_lambda(IConstructor $captureDefault, IList $captures, IConstructor $declarator, IConstructor $body, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$captureDefault.getType().isSubtypeOf(_Modifier)) {
      throw new IllegalArgumentException("Expected " + _Modifier + " but got " + $captureDefault.getType() + " for $captureDefault:" + $captureDefault);
    }
      
    if (!$captures.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $captures.getType() + " for $captures:" + $captures);
    }
      
    if (!$declarator.getType().isSubtypeOf(_Declarator)) {
      throw new IllegalArgumentException("Expected " + _Declarator + " but got " + $declarator.getType() + " for $declarator:" + $declarator);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_lambda_4 , $captureDefault, $captures, $declarator, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_shiftLeft(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_shiftLeft_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_plusAssign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_plusAssign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_prefixDecr(IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_prefixDecr_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_binaryXorAssign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_binaryXorAssign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_constCast(IConstructor $typeId, IConstructor $expression, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_constCast_2 , $typeId, $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Expression_shiftRightAssign(IConstructor $lhs, IConstructor $rhs, ISourceLocation $loc, IConstructor $typ) {
      
    if (!$lhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $lhs.getType() + " for $lhs:" + $lhs);
    }
      
    if (!$rhs.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $rhs.getType() + " for $rhs:" + $rhs);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Expression_shiftRightAssign_2 , $lhs, $rhs).asWithKeywordParameters().setParameters(kwParams);
  }
  
  
  public IConstructor Type_wchar_t(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_wchar_t_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_decltype(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_decltype_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_decimal128(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_decimal128_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_nullptr(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_nullptr_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_int128(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_int128_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_classType(IConstructor $name, ISourceLocation $loc) {
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_classType_1 , $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_unionType(IConstructor $name, ISourceLocation $loc) {
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_unionType_1 , $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_basicType(IConstructor $type, IList $modifiers, ISourceLocation $loc) {
      
    if (!$type.getType().isSubtypeOf(_Type)) {
      throw new IllegalArgumentException("Expected " + _Type + " but got " + $type.getType() + " for $type:" + $type);
    }
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_Modifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Modifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_basicType_2 , $type, $modifiers).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_char(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_char_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_unspecified(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_unspecified_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_arrayType(IConstructor $type, IValue $size, ISourceLocation $loc) {
      
    if (!$type.getType().isSubtypeOf(_Type)) {
      throw new IllegalArgumentException("Expected " + _Type + " but got " + $type.getType() + " for $type:" + $type);
    }
      
    if (!$size.getType().isSubtypeOf(tf.integerType())) {
      throw new IllegalArgumentException("Expected " + tf.integerType() + " but got " + $size.getType() + " for $size:" + $size);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_arrayType_2 , $type, $size).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_float128(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_float128_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_float(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_float_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_integer(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_integer_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_char32_t(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_char32_t_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_bool(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_bool_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_decimal64(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_decimal64_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_auto(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_auto_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_decimal32(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_decimal32_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_char16_t(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_char16_t_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_typeof(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_typeof_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_double(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_double_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_void(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_void_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Type_structType(IConstructor $name, ISourceLocation $loc) {
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Type_structType_1 , $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  
  public IConstructor Statement_for(IConstructor $sInitializer, IConstructor $condition, IConstructor $iteration, IConstructor $body, IList $attributes, ISourceLocation $loc) {
      
    if (!$sInitializer.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $sInitializer.getType() + " for $sInitializer:" + $sInitializer);
    }
      
    if (!$condition.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $condition.getType() + " for $condition:" + $condition);
    }
      
    if (!$iteration.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $iteration.getType() + " for $iteration:" + $iteration);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_for_4 , $sInitializer, $condition, $iteration, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_expressionStatement(IConstructor $expression, IList $attributes, ISourceLocation $loc) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_expressionStatement_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_forWithDecl(IConstructor $sInitializer, IConstructor $conditionDeclaration, IConstructor $iteration, IConstructor $body, IList $attributes, ISourceLocation $loc) {
      
    if (!$sInitializer.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $sInitializer.getType() + " for $sInitializer:" + $sInitializer);
    }
      
    if (!$conditionDeclaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $conditionDeclaration.getType() + " for $conditionDeclaration:" + $conditionDeclaration);
    }
      
    if (!$iteration.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $iteration.getType() + " for $iteration:" + $iteration);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_forWithDecl_4 , $sInitializer, $conditionDeclaration, $iteration, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_nullStatement(IList $attributes, ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_nullStatement_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_ifWithDecl(IConstructor $conditionDeclaration, IConstructor $thenClause, IList $attributes, ISourceLocation $loc) {
      
    if (!$conditionDeclaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $conditionDeclaration.getType() + " for $conditionDeclaration:" + $conditionDeclaration);
    }
      
    if (!$thenClause.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $thenClause.getType() + " for $thenClause:" + $thenClause);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_ifWithDecl_2 , $conditionDeclaration, $thenClause).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_return(IList $attributes, ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_return_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_defaultCase(IList $attributes, ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_defaultCase_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_label(IConstructor $name, IConstructor $nestedStatement, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$nestedStatement.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $nestedStatement.getType() + " for $nestedStatement:" + $nestedStatement);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Statement_label_2 , $name, $nestedStatement).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_continue(IList $attributes, ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_continue_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_problem(String $raw, ISourceLocation $loc) {
      
    if (!vf.string($raw).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($raw).getType() + " for vf.string($raw):" + vf.string($raw));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_problem_1 , vf.string($raw)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_catch(IConstructor $declaration, IConstructor $body, IList $attributes, ISourceLocation $loc) {
      
    if (!$declaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $declaration.getType() + " for $declaration:" + $declaration);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_catch_2 , $declaration, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_catchAll(IConstructor $body, IList $attributes, ISourceLocation $loc) {
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_catchAll_1 , $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_declarationStatement(IConstructor $declaration, IList $attributes, ISourceLocation $loc) {
      
    if (!$declaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $declaration.getType() + " for $declaration:" + $declaration);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_declarationStatement_1 , $declaration).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_switchWithDecl(IConstructor $controllerDeclaration, IConstructor $body, IList $attributes, ISourceLocation $loc) {
      
    if (!$controllerDeclaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $controllerDeclaration.getType() + " for $controllerDeclaration:" + $controllerDeclaration);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_switchWithDecl_2 , $controllerDeclaration, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_compoundStatement(IList $statements, IList $attributes, ISourceLocation $loc) {
      
    if (!$statements.getType().isSubtypeOf(tf.listType(_Statement))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Statement) + " but got " + $statements.getType() + " for $statements:" + $statements);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_compoundStatement_1 , $statements).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_case(IConstructor $expression, IList $attributes, ISourceLocation $loc) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_case_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_rangeBasedFor(IConstructor $declaration, IConstructor $initializer, IConstructor $body, IList $attributes, ISourceLocation $loc) {
      
    if (!$declaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $declaration.getType() + " for $declaration:" + $declaration);
    }
      
    if (!$initializer.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $initializer.getType() + " for $initializer:" + $initializer);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_rangeBasedFor_3 , $declaration, $initializer, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_goto(IConstructor $name, IList $attributes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Statement_goto_1 , $name).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_return(IConstructor $expression, IList $attributes, ISourceLocation $loc) {
      
    if (!$expression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $expression.getType() + " for $expression:" + $expression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_return_1 , $expression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_while(IConstructor $condition, IConstructor $body, IList $attributes, ISourceLocation $loc) {
      
    if (!$condition.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $condition.getType() + " for $condition:" + $condition);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_while_2 , $condition, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_if(IConstructor $condition, IConstructor $thenClause, IConstructor $elseClause, IList $attributes, ISourceLocation $loc) {
      
    if (!$condition.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $condition.getType() + " for $condition:" + $condition);
    }
      
    if (!$thenClause.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $thenClause.getType() + " for $thenClause:" + $thenClause);
    }
      
    if (!$elseClause.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $elseClause.getType() + " for $elseClause:" + $elseClause);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_if_3 , $condition, $thenClause, $elseClause).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_break(IList $attributes, ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_break_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_ifWithDecl(IConstructor $conditionDeclaration, IConstructor $thenClause, IConstructor $elseClause, IList $attributes, ISourceLocation $loc) {
      
    if (!$conditionDeclaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $conditionDeclaration.getType() + " for $conditionDeclaration:" + $conditionDeclaration);
    }
      
    if (!$thenClause.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $thenClause.getType() + " for $thenClause:" + $thenClause);
    }
      
    if (!$elseClause.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $elseClause.getType() + " for $elseClause:" + $elseClause);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_ifWithDecl_3 , $conditionDeclaration, $thenClause, $elseClause).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_switch(IConstructor $controller, IConstructor $body, IList $attributes, ISourceLocation $loc) {
      
    if (!$controller.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $controller.getType() + " for $controller:" + $controller);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_switch_2 , $controller, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_whileWithDecl(IConstructor $conditionDeclaration, IConstructor $body, IList $attributes, ISourceLocation $loc) {
      
    if (!$conditionDeclaration.getType().isSubtypeOf(_Declaration)) {
      throw new IllegalArgumentException("Expected " + _Declaration + " but got " + $conditionDeclaration.getType() + " for $conditionDeclaration:" + $conditionDeclaration);
    }
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_whileWithDecl_2 , $conditionDeclaration, $body).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_if(IConstructor $condition, IConstructor $thenClause, IList $attributes, ISourceLocation $loc) {
      
    if (!$condition.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $condition.getType() + " for $condition:" + $condition);
    }
      
    if (!$thenClause.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $thenClause.getType() + " for $thenClause:" + $thenClause);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_if_2 , $condition, $thenClause).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_tryBlock(IConstructor $tryBody, IList $catchHandlers, IList $attributes, ISourceLocation $loc) {
      
    if (!$tryBody.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $tryBody.getType() + " for $tryBody:" + $tryBody);
    }
      
    if (!$catchHandlers.getType().isSubtypeOf(tf.listType(_Statement))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Statement) + " but got " + $catchHandlers.getType() + " for $catchHandlers:" + $catchHandlers);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_tryBlock_2 , $tryBody, $catchHandlers).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Statement_do(IConstructor $body, IConstructor $condition, IList $attributes, ISourceLocation $loc) {
      
    if (!$body.getType().isSubtypeOf(_Statement)) {
      throw new IllegalArgumentException("Expected " + _Statement + " but got " + $body.getType() + " for $body:" + $body);
    }
      
    if (!$condition.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $condition.getType() + " for $condition:" + $condition);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    if (!$attributes.isEmpty()) {
      kwParams.put("attributes", $attributes);
    }
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Statement_do_2 , $body, $condition).asWithKeywordParameters().setParameters(kwParams);
  }
  
  
  public IConstructor Modifier_override(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_override_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_captDefByCopy(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_captDefByCopy_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_public(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_public_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_typename(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_typename_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_mutable(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_mutable_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_threadLocal(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_threadLocal_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_extern(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_extern_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_friend(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_friend_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_unsigned(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_unsigned_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_final(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_final_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_complex(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_complex_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_protected(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_protected_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_static(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_static_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_virtual(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_virtual_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_typedef(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_typedef_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_const(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_const_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_register(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_register_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_private(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_private_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_signed(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_signed_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_restrict(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_restrict_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_long(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_long_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_volatile(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_volatile_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_short(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_short_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_inline(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_inline_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_imaginary(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_imaginary_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_constexpr(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_constexpr_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_longlong(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_longlong_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_explicit(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_explicit_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_captDefUnspecified(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_captDefUnspecified_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_modAuto(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_modAuto_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_captDefByReference(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_captDefByReference_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_unspecifiedInheritance(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_unspecifiedInheritance_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Modifier_pureVirtual(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Modifier_pureVirtual_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  
  public IConstructor TypeSymbol_typedef(IConstructor $type) {
      
    if (!$type.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $type.getType() + " for $type:" + $type);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_typedef_1 , $type).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_problemType(String $msg) {
      
    if (!vf.string($msg).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($msg).getType() + " for vf.string($msg):" + vf.string($msg));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_problemType_1 , vf.string($msg)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_union(ISourceLocation $decl) {
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_union_1 , $decl).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_float() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_float_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_unspecified() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_unspecified_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_eUnionTemplate(ISourceLocation $decl, IList $templateParameters) {
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
      
    if (!$templateParameters.getType().isSubtypeOf(tf.listType(tf.sourceLocationType()))) {
      throw new IllegalArgumentException("Expected " + tf.listType(tf.sourceLocationType()) + " but got " + $templateParameters.getType() + " for $templateParameters:" + $templateParameters);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_eUnionTemplate_2 , $decl, $templateParameters).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_class(ISourceLocation $decl) {
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_class_1 , $decl).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_eClassTemplate(ISourceLocation $decl, IList $templateParameters) {
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
      
    if (!$templateParameters.getType().isSubtypeOf(tf.listType(tf.sourceLocationType()))) {
      throw new IllegalArgumentException("Expected " + tf.listType(tf.sourceLocationType()) + " but got " + $templateParameters.getType() + " for $templateParameters:" + $templateParameters);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_eClassTemplate_2 , $decl, $templateParameters).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_templateTypeParameter(ISourceLocation $owner, ISourceLocation $decl) {
      
    if (!$owner.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $owner.getType() + " for $owner:" + $owner);
    }
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_templateTypeParameter_2 , $owner, $decl).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_cClassTemplate(ISourceLocation $decl, IList $templateParameters) {
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
      
    if (!$templateParameters.getType().isSubtypeOf(tf.listType(tf.sourceLocationType()))) {
      throw new IllegalArgumentException("Expected " + tf.listType(tf.sourceLocationType()) + " but got " + $templateParameters.getType() + " for $templateParameters:" + $templateParameters);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_cClassTemplate_2 , $decl, $templateParameters).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_functionType(IConstructor $returnType, IList $parameterTypes) {
      
    if (!$returnType.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $returnType.getType() + " for $returnType:" + $returnType);
    }
      
    if (!$parameterTypes.getType().isSubtypeOf(tf.listType(_TypeSymbol))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_TypeSymbol) + " but got " + $parameterTypes.getType() + " for $parameterTypes:" + $parameterTypes);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_functionType_2 , $returnType, $parameterTypes).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_functionTypeVarArgs(IConstructor $returnType, IList $parameterTypes) {
      
    if (!$returnType.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $returnType.getType() + " for $returnType:" + $returnType);
    }
      
    if (!$parameterTypes.getType().isSubtypeOf(tf.listType(_TypeSymbol))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_TypeSymbol) + " but got " + $parameterTypes.getType() + " for $parameterTypes:" + $parameterTypes);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_functionTypeVarArgs_2 , $returnType, $parameterTypes).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_eStructTemplate(ISourceLocation $decl, IList $templateParameters) {
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
      
    if (!$templateParameters.getType().isSubtypeOf(tf.listType(tf.sourceLocationType()))) {
      throw new IllegalArgumentException("Expected " + tf.listType(tf.sourceLocationType()) + " but got " + $templateParameters.getType() + " for $templateParameters:" + $templateParameters);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_eStructTemplate_2 , $decl, $templateParameters).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_templateTemplate(IConstructor $child, IList $templateParameters) {
      
    if (!$child.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $child.getType() + " for $child:" + $child);
    }
      
    if (!$templateParameters.getType().isSubtypeOf(tf.listType(tf.sourceLocationType()))) {
      throw new IllegalArgumentException("Expected " + tf.listType(tf.sourceLocationType()) + " but got " + $templateParameters.getType() + " for $templateParameters:" + $templateParameters);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_templateTemplate_2 , $child, $templateParameters).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_noType() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_noType_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_float128() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_float128_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_variableTemplate(ISourceLocation $decl, IList $templateParameters) {
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
      
    if (!$templateParameters.getType().isSubtypeOf(tf.listType(tf.sourceLocationType()))) {
      throw new IllegalArgumentException("Expected " + tf.listType(tf.sourceLocationType()) + " but got " + $templateParameters.getType() + " for $templateParameters:" + $templateParameters);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_variableTemplate_2 , $decl, $templateParameters).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_unknownMemberClass(ISourceLocation $owner, String $name) {
      
    if (!$owner.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $owner.getType() + " for $owner:" + $owner);
    }
      
    if (!vf.string($name).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($name).getType() + " for vf.string($name):" + vf.string($name));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_unknownMemberClass_2 , $owner, vf.string($name)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_char16() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_char16_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_functionTemplate(ISourceLocation $decl, IList $templateParameters) {
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
      
    if (!$templateParameters.getType().isSubtypeOf(tf.listType(tf.sourceLocationType()))) {
      throw new IllegalArgumentException("Expected " + tf.listType(tf.sourceLocationType()) + " but got " + $templateParameters.getType() + " for $templateParameters:" + $templateParameters);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_functionTemplate_2 , $decl, $templateParameters).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_cStructTemplate(ISourceLocation $decl, IList $templateParameters) {
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
      
    if (!$templateParameters.getType().isSubtypeOf(tf.listType(tf.sourceLocationType()))) {
      throw new IllegalArgumentException("Expected " + tf.listType(tf.sourceLocationType()) + " but got " + $templateParameters.getType() + " for $templateParameters:" + $templateParameters);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_cStructTemplate_2 , $decl, $templateParameters).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_typeOfDependentExpression(ISourceLocation $src) {
      
    if (!$src.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $src.getType() + " for $src:" + $src);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_typeOfDependentExpression_1 , $src).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_array(IConstructor $baseType) {
      
    if (!$baseType.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $baseType.getType() + " for $baseType:" + $baseType);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_array_1 , $baseType).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_qualifierType(IList $modifiers, IConstructor $type) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_TypeModifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_TypeModifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$type.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $type.getType() + " for $type:" + $type);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_qualifierType_2 , $modifiers, $type).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_unresolved() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_unresolved_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_double() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_double_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_decimal32() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_decimal32_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_enumerationSpecialization(ISourceLocation $specializedBinding, IList $templateArguments) {
      
    if (!$specializedBinding.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $specializedBinding.getType() + " for $specializedBinding:" + $specializedBinding);
    }
      
    if (!$templateArguments.getType().isSubtypeOf(tf.listType(_TypeSymbol))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_TypeSymbol) + " but got " + $templateArguments.getType() + " for $templateArguments:" + $templateArguments);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_enumerationSpecialization_2 , $specializedBinding, $templateArguments).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_char32() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_char32_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_enumeration(ISourceLocation $decl) {
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_enumeration_1 , $decl).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_typeContainer(IConstructor $type) {
      
    if (!$type.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $type.getType() + " for $type:" + $type);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_typeContainer_1 , $type).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_void() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_void_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_char() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_char_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_functionSetTypePointer(ISourceLocation $decl, IList $templateArguments) {
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
      
    if (!$templateArguments.getType().isSubtypeOf(tf.listType(_TypeSymbol))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_TypeSymbol) + " but got " + $templateArguments.getType() + " for $templateArguments:" + $templateArguments);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_functionSetTypePointer_2 , $decl, $templateArguments).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_referenceType(IConstructor $type) {
      
    if (!$type.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $type.getType() + " for $type:" + $type);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_referenceType_1 , $type).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_boolean() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_boolean_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_int128() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_int128_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_cUnionTemplate(ISourceLocation $decl, IList $templateParameters) {
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
      
    if (!$templateParameters.getType().isSubtypeOf(tf.listType(tf.sourceLocationType()))) {
      throw new IllegalArgumentException("Expected " + tf.listType(tf.sourceLocationType()) + " but got " + $templateParameters.getType() + " for $templateParameters:" + $templateParameters);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_cUnionTemplate_2 , $decl, $templateParameters).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_functionSetType(ISourceLocation $decl, IList $templateArguments) {
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
      
    if (!$templateArguments.getType().isSubtypeOf(tf.listType(_TypeSymbol))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_TypeSymbol) + " but got " + $templateArguments.getType() + " for $templateArguments:" + $templateArguments);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_functionSetType_2 , $decl, $templateArguments).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_implicitTemplateTypeParameter(ISourceLocation $owner, IValue $position) {
      
    if (!$owner.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $owner.getType() + " for $owner:" + $owner);
    }
      
    if (!$position.getType().isSubtypeOf(tf.integerType())) {
      throw new IllegalArgumentException("Expected " + tf.integerType() + " but got " + $position.getType() + " for $position:" + $position);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_implicitTemplateTypeParameter_2 , $owner, $position).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_pointerType(IList $modifiers, IConstructor $type) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_TypeModifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_TypeModifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$type.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $type.getType() + " for $type:" + $type);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_pointerType_2 , $modifiers, $type).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_eEnumTemplate(ISourceLocation $decl, IList $templateParameters) {
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
      
    if (!$templateParameters.getType().isSubtypeOf(tf.listType(tf.sourceLocationType()))) {
      throw new IllegalArgumentException("Expected " + tf.listType(tf.sourceLocationType()) + " but got " + $templateParameters.getType() + " for $templateParameters:" + $templateParameters);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_eEnumTemplate_2 , $decl, $templateParameters).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_wchar() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_wchar_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_any() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_any_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_classSpecialization(ISourceLocation $decl, IList $templateArguments) {
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
      
    if (!$templateArguments.getType().isSubtypeOf(tf.listType(_TypeSymbol))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_TypeSymbol) + " but got " + $templateArguments.getType() + " for $templateArguments:" + $templateArguments);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_classSpecialization_2 , $decl, $templateArguments).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_parameterPackType(IConstructor $type) {
      
    if (!$type.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $type.getType() + " for $type:" + $type);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_parameterPackType_1 , $type).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_decimal64() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_decimal64_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_int() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_int_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_struct(IList $fields) {
      
    if (!$fields.getType().isSubtypeOf(tf.listType(_TypeSymbol))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_TypeSymbol) + " but got " + $fields.getType() + " for $fields:" + $fields);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_struct_1 , $fields).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_deferredClassInstance(String $name) {
      
    if (!vf.string($name).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($name).getType() + " for vf.string($name):" + vf.string($name));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_deferredClassInstance_1 , vf.string($name)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_array(IConstructor $baseType, IValue $size) {
      
    if (!$baseType.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $baseType.getType() + " for $baseType:" + $baseType);
    }
      
    if (!$size.getType().isSubtypeOf(tf.integerType())) {
      throw new IllegalArgumentException("Expected " + tf.integerType() + " but got " + $size.getType() + " for $size:" + $size);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_array_2 , $baseType, $size).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_aliasTemplate(ISourceLocation $decl, IList $templateParameters) {
      
    if (!$decl.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $decl.getType() + " for $decl:" + $decl);
    }
      
    if (!$templateParameters.getType().isSubtypeOf(tf.listType(tf.sourceLocationType()))) {
      throw new IllegalArgumentException("Expected " + tf.listType(tf.sourceLocationType()) + " but got " + $templateParameters.getType() + " for $templateParameters:" + $templateParameters);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_aliasTemplate_2 , $decl, $templateParameters).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_nullPtr() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_nullPtr_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_decimal128() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_decimal128_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_basicType(IList $modifiers, IConstructor $baseType) {
      
    if (!$modifiers.getType().isSubtypeOf(tf.listType(_TypeModifier))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_TypeModifier) + " but got " + $modifiers.getType() + " for $modifiers:" + $modifiers);
    }
      
    if (!$baseType.getType().isSubtypeOf(_TypeSymbol)) {
      throw new IllegalArgumentException("Expected " + _TypeSymbol + " but got " + $baseType.getType() + " for $baseType:" + $baseType);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_basicType_2 , $modifiers, $baseType).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeSymbol_problemBinding() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeSymbol_problemBinding_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  
  public IConstructor Attribute_alignmentSpecifier(IConstructor $typeIdOrExpression, ISourceLocation $loc) {
      
    if (!$typeIdOrExpression.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeIdOrExpression.getType() + " for $typeIdOrExpression:" + $typeIdOrExpression);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Attribute_alignmentSpecifier_1 , $typeIdOrExpression).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Attribute_attribute(String $name, ISourceLocation $loc) {
      
    if (!vf.string($name).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($name).getType() + " for vf.string($name):" + vf.string($name));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Attribute_attribute_1 , vf.string($name)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Attribute_attributeSpecifier(IList $attributes, ISourceLocation $loc) {
      
    if (!$attributes.getType().isSubtypeOf(tf.listType(_Attribute))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Attribute) + " but got " + $attributes.getType() + " for $attributes:" + $attributes);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Attribute_attributeSpecifier_1 , $attributes).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Attribute_attribute(String $name, String $argumentClause, ISourceLocation $loc) {
      
    if (!vf.string($name).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($name).getType() + " for vf.string($name):" + vf.string($name));
    }
      
    if (!vf.string($argumentClause).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($argumentClause).getType() + " for vf.string($argumentClause):" + vf.string($argumentClause));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Attribute_attribute_2 , vf.string($name), vf.string($argumentClause)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  
  public IConstructor TypeModifier_unsigned() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeModifier_unsigned_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeModifier_complex() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeModifier_complex_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeModifier_imaginary() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeModifier_imaginary_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeModifier_longlong() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeModifier_longlong_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeModifier_const() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeModifier_const_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeModifier_static() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeModifier_static_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeModifier_short() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeModifier_short_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeModifier_volatile() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeModifier_volatile_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeModifier_long() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeModifier_long_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeModifier_restrict() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeModifier_restrict_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor TypeModifier_signed() {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_TypeModifier_signed_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  
  public IConstructor M3_m3(ISourceLocation $id) {
      
    if (!$id.getType().isSubtypeOf(tf.sourceLocationType())) {
      throw new IllegalArgumentException("Expected " + tf.sourceLocationType() + " but got " + $id.getType() + " for $id:" + $id);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    
    
    
    return vf.constructor(_M3_m3_1 , $id).asWithKeywordParameters().setParameters(kwParams);
  }
  
  
  public IConstructor Name_conversionName(String $value, IConstructor $typeId, ISourceLocation $loc, IConstructor $typ) {
      
    if (!vf.string($value).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($value).getType() + " for vf.string($value):" + vf.string($value));
    }
      
    if (!$typeId.getType().isSubtypeOf(_Expression)) {
      throw new IllegalArgumentException("Expected " + _Expression + " but got " + $typeId.getType() + " for $typeId:" + $typeId);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    kwParams.put("typ", $typ);
    return vf.constructor(_Name_conversionName_2 , vf.string($value), $typeId).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Name_qualifiedName(IList $qualifiers, IConstructor $lastName, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$qualifiers.getType().isSubtypeOf(tf.listType(_Name))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Name) + " but got " + $qualifiers.getType() + " for $qualifiers:" + $qualifiers);
    }
      
    if (!$lastName.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $lastName.getType() + " for $lastName:" + $lastName);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Name_qualifiedName_2 , $qualifiers, $lastName).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Name_name(String $value, ISourceLocation $loc) {
      
    if (!vf.string($value).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($value).getType() + " for vf.string($value):" + vf.string($value));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Name_name_1 , vf.string($value)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Name_operatorName(String $value, ISourceLocation $loc) {
      
    if (!vf.string($value).getType().isSubtypeOf(tf.stringType())) {
      throw new IllegalArgumentException("Expected " + tf.stringType() + " but got " + vf.string($value).getType() + " for vf.string($value):" + vf.string($value));
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Name_operatorName_1 , vf.string($value)).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Name_abstractEmptyName(ISourceLocation $loc) {
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    
    
    return vf.constructor(_Name_abstractEmptyName_0 ).asWithKeywordParameters().setParameters(kwParams);
  }
  
  public IConstructor Name_templateId(IConstructor $name, IList $argumentTypes, ISourceLocation $loc, ISourceLocation $decl) {
      
    if (!$name.getType().isSubtypeOf(_Name)) {
      throw new IllegalArgumentException("Expected " + _Name + " but got " + $name.getType() + " for $name:" + $name);
    }
      
    if (!$argumentTypes.getType().isSubtypeOf(tf.listType(_Expression))) {
      throw new IllegalArgumentException("Expected " + tf.listType(_Expression) + " but got " + $argumentTypes.getType() + " for $argumentTypes:" + $argumentTypes);
    }
    
    Map<String, IValue> kwParams = new HashMap<String, IValue>();
    
    kwParams.put("src", $loc);
    kwParams.put("decl", $decl);
    
    return vf.constructor(_Name_templateId_2 , $name, $argumentTypes).asWithKeywordParameters().setParameters(kwParams);
  }
 
  
}